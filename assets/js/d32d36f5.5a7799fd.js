"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[5480],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=c(a),u=i,k=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return a?n.createElement(k,l(l({ref:t},p),{},{components:a})):n.createElement(k,l({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,l=new Array(o);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var c=2;c<o;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},85162:(e,t,a)=>{a.d(t,{Z:()=>l});var n=a(67294),i=a(34334);const o="tabItem_Ymn6";function l(e){let{children:t,hidden:a,className:l}=e;return n.createElement("div",{role:"tabpanel",className:(0,i.Z)(o,l),hidden:a},t)}},65488:(e,t,a)=>{a.d(t,{Z:()=>u});var n=a(83117),i=a(67294),o=a(34334),l=a(72389),r=a(67392),s=a(7094),c=a(12466);const p="tabList__CuJ",d="tabItem_LNqP";function m(e){var t;const{lazy:a,block:l,defaultValue:m,values:u,groupId:k,className:h}=e,g=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=u??g.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),f=(0,r.l)(b,((e,t)=>e.value===t.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const N=null===m?m:m??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==N&&!b.some((e=>e.value===N)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${N}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:v,setTabGroupChoices:y}=(0,s.U)(),[S,B]=(0,i.useState)(N),C=[],{blockElementScrollPositionUntilNextRender:w}=(0,c.o5)();if(null!=k){const e=v[k];null!=e&&e!==S&&b.some((t=>t.value===e))&&B(e)}const T=e=>{const t=e.currentTarget,a=C.indexOf(t),n=b[a].value;n!==S&&(w(t),B(n),null!=k&&y(k,String(n)))},D=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{const t=C.indexOf(e.currentTarget)+1;a=C[t]??C[0];break}case"ArrowLeft":{const t=C.indexOf(e.currentTarget)-1;a=C[t]??C[C.length-1];break}}null==(t=a)||t.focus()};return i.createElement("div",{className:(0,o.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":l},h)},b.map((e=>{let{value:t,label:a,attributes:l}=e;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:S===t?0:-1,"aria-selected":S===t,key:t,ref:e=>C.push(e),onKeyDown:D,onFocus:T,onClick:T},l,{className:(0,o.Z)("tabs__item",d,null==l?void 0:l.className,{"tabs__item--active":S===t})}),a??t)}))),a?(0,i.cloneElement)(g.filter((e=>e.props.value===S))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==S})))))}function u(e){const t=(0,l.Z)();return i.createElement(m,(0,n.Z)({key:String(t)},e))}},25084:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var n=a(83117),i=(a(67294),a(3905)),o=a(65488),l=a(85162);const r={sidebar_position:3,title:"Built-in Filters"},s=void 0,c={unversionedId:"cache/multiview-cache/builtin-filter",id:"cache/multiview-cache/builtin-filter",title:"Built-in Filters",description:"Define Soft Delete Flag",source:"@site/docs/cache/multiview-cache/builtin-filter.mdx",sourceDirName:"cache/multiview-cache",slug:"/cache/multiview-cache/builtin-filter",permalink:"/jimmer/docs/cache/multiview-cache/builtin-filter",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/cache/multiview-cache/builtin-filter.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Built-in Filters"},sidebar:"tutorialSidebar",previous:{title:"Custom Filters",permalink:"/jimmer/docs/cache/multiview-cache/user-filter"},next:{title:"Cache Abandoned Reason",permalink:"/jimmer/docs/cache/multiview-cache/abandoned-callback"}},p={},d=[{value:"Define Soft Delete Flag",id:"define-soft-delete-flag",level:2},{value:"Enable multi-view caching",id:"enable-multi-view-caching",level:2},{value:"SubKey of Calculated Properties",id:"subkey-of-calculated-properties",level:2},{value:"Usage",id:"usage",level:2},{value:"Normal Usage",id:"normal-usage",level:3},{value:"Adjust Filtering Behavior",id:"adjust-filtering-behavior",level:3},{value:"Consistency",id:"consistency",level:2}],m={toc:d};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"define-soft-delete-flag"},"Define Soft Delete Flag"),(0,i.kt)("p",null,"Jimmer supports logical delete, for example"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Book.java"',title:'"Book.java"'},'@Entity\npublic interface Book {\n\n    @LogicalDeleted(\n        value = "true",\n        // highlight-next-line\n        useMultiViewCache = true\n    )\n    boolean isDeleted();\n\n    ...other code omitted...\n}\n'))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Book.kt"',title:'"Book.kt"'},'@Entity\ninterface Book {\n\n    @LogicalDeleted(\n        value = "true",\n        // highlight-next-line\n        useMultiViewCache = true\n    )\n    val isDeleted: Boolean\n\n    ...other code omitted...\n}\n')))),(0,i.kt)("p",null,"Here is the English translation:"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"useMultiViewCache = true")," in the above code is very important. "),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@LogicalDeleted")," uses the built-in global filter to implement the soft delete logic. "),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"useMultiViewCache")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"@LogicalDeleted")," annotation is false,\nthe corresponding built-in filter only implements ",(0,i.kt)("inlineCode",{parentName:"li"},"Filter/KFilter")," interfaces, which is unfriendly to caching. "),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"useMultiViewCache")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"@LogicalDeleted")," annotation is true,\nthe corresponding built-in filter only implements ",(0,i.kt)("inlineCode",{parentName:"li"},"CacheableFilter/KCacheableFilter")," interfaces, which is caching-friendly. ")),(0,i.kt)("p",{parentName:"admonition"},"The default value of this property is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", indicating that all properties sensitive to this filter\n",(0,i.kt)("em",{parentName:"p"},"(",(0,i.kt)("inlineCode",{parentName:"em"},"BookStore.books"),", ",(0,i.kt)("inlineCode",{parentName:"em"},"Author.books"),", ",(0,i.kt)("inlineCode",{parentName:"em"},"BookStore.avgPrice"),", and ",(0,i.kt)("inlineCode",{parentName:"em"},"BookStore.newestBooks"),")")," do NOT support caching,\nwhich is a more conservative option. "),(0,i.kt)("p",{parentName:"admonition"},"To make all these properties cacheable, ",(0,i.kt)("inlineCode",{parentName:"p"},"useMultiViewCache = true")," must be configured. ")),(0,i.kt)("h2",{id:"enable-multi-view-caching"},"Enable multi-view caching"),(0,i.kt)("p",null,"How to enable multi-view caching has already been discussed in detail in the ",(0,i.kt)("a",{parentName:"p",href:"./user-filter"},"previous document"),",\nso I will not repeat it here."),(0,i.kt)("h2",{id:"subkey-of-calculated-properties"},"SubKey of Calculated Properties"),(0,i.kt)("p",null,"Logical delete is a built-in filter, and all affected association properties will automatically specify ",(0,i.kt)("inlineCode",{parentName:"p"},"SubKey")," for their association caches."),(0,i.kt)("p",null,"However, unfortunately, due to the introduction of user-defined calculation rules that the framework cannot understand, developers must manually specify ",(0,i.kt)("inlineCode",{parentName:"p"},"SubKey")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Resolver")," implementation of calculated properties."),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStoreAvgPriceResolver.java"',title:'"BookStoreAvgPriceResolver.java"'},"@Component\npublic class BookStoreAvgPriceResolver implements TransientResolver<Long, BigDecimal> {\n    \n    private final JSqlClient sqlClient;\n\n    @Override\n    public Ref<SortedMap<String, Object>> getParameterMapRef() {\n        return sqlClient\n            .getFilters()\n            // highlight-next-line\n            .getTargetParameterMapRef(BookStoreProps.BOOKS);\n    }\n\n    ...other code omitted...\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStoreAvgPriceResolver.kt"',title:'"BookStoreAvgPriceResolver.kt"'},"@Compoent\nclass BookStoreAvgPriceResolver(\n    private val sqlClient: KSqlClient\n) : KTransientResolver<Long, BigDecimal> {\n\n    override fun getParameterMapRef(): Ref<SortedMap<String, Any>?>? {\n        return sqlClient\n            .filters\n            // highlight-next-line\n            .getTargetParameterMapRef(BookStore::books)\n    }\n\n    ...other code omitted... \n}\n")))),(0,i.kt)("p",null,"Obviously, the calculated property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," is actually determined by the association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books")," and changes with it. "),(0,i.kt)("p",null,"Therefore, whatever ",(0,i.kt)("inlineCode",{parentName:"p"},"SubKey")," the association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books")," specifies for the multi-view cache system in the current invocation context, the calculated property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," should specify the same one."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," is also affected by ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price"),". It changes when ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price")," changes."),(0,i.kt)("p",{parentName:"admonition"},"However, ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price")," is a non-association property of the object, so it is irrelevant to the multi-view cache system. The ",(0,i.kt)("inlineCode",{parentName:"p"},"getParameterMapRef")," method does not need to consider it here.")),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("h3",{id:"normal-usage"},"Normal Usage"),(0,i.kt)("p",null,"Now that we have made the association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books")," and the calculated property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," support multi-view cache, let's use object fetchers to query them"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookStoreTable table = BookStoreTable.$;\nList<BookStore> stores = sqlClient\n    .createQuery(table)\n    .select(\n        table.fetch(\n            BookStoreFetcher.$\n                .allScalarFields()\n                .books( \u2776\n                    BookFetcher.$\n                        .allScalarFields()\n                )\n                .avgPrice() \u2777\n        )\n    )\n    .execute();\nSystem.out.println(stores); \n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val stores = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.fetchBy {\n                allScalarFields()\n                books { \u2776\n                    allScalarFields()\n                }\n                avgPrice() \u2777\n            }\n        )\n    }\n    .execute()\nprintln(stores)\n")))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Step 1: Query the aggregate root"),(0,i.kt)("p",{parentName:"li"},"First query the aggregate root objects by executing the following SQL"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.WEBSITE \nfrom BOOK_STORE tb_1_\n")),(0,i.kt)("p",{parentName:"li"},"This implements the query in the code and obtains some BookStore objects. Such objects directly queried by users are called aggregate root objects."),(0,i.kt)("admonition",{parentName:"li",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Jimmer does NOT cache the returned aggregate objects queried by users because the consistency of such query results cannot be guaranteed.\nEven if cache them at the cost of sacrificing consistency is required, it should be handled by users as a business problem rather than an behavior that should be abstracted and unified by the framework."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Step 2: Query ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books")," \u2776 via association cache"),(0,i.kt)("p",{parentName:"li"},"The above code will obtain a list of aggregate root objects. If using the official sample data, it will get two aggregate root objects with ",(0,i.kt)("inlineCode",{parentName:"p"},"ID")," of 1 and 2."),(0,i.kt)("p",{parentName:"li"},"Jimmer first looks up the data in Redis with keys ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-2"),". "),(0,i.kt)("p",{parentName:"li"},"Assuming the data for these keys cannot be found in Redis"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"127.0.0.1:6379> keys BookStore.books-*\n(empty array)\n")),(0,i.kt)("p",{parentName:"li"},"Then the following SQL is executed to resolve the association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.STORE_ID,\n    tb_1_.ID\nfrom BOOK tb_1_  \nwhere\n        tb_1_.STORE_ID in (\n            ? /* 1 */, ? /* 2 */  \n        )\n    and\n        // highlight-next-line\n        tb_1_.DELETED = ? /* false */\norder by\n    tb_1_.NAME asc, \n    tb_1_.EDITION desc\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The filtering condition ",(0,i.kt)("inlineCode",{parentName:"p"},"tb_1_.DELETED = false")," comes from the implicit built-in filter of the logical delete feature. ")),(0,i.kt)("p",{parentName:"li"},"Jimmer will put the query results into Redis, so we can view the data in redis:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'127.0.0.1:6379> keys BookStore.books-*  \n1) "BookStore.books-2"\n2) "BookStore.books-1"\n\n127.0.0.1:6379> hgetall BookStore.books-1\n# highlight-next-line  \n1) "{\\"logicalDeleted\\":false}"\n2) "[6,5,3,2,9,8]"\n\n127.0.0.1:6379> hgetall BookStore.books-2\n# highlight-next-line\n1) "{\\"logicalDeleted\\":false}" \n2) "[12,11]"\n')),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The multi-view cache uses Redis Hash structure, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"hgetall")," command of redis is needed instead of simple ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),". "),(0,i.kt)("p",{parentName:"admonition"},"Redis Hash is a nested two-layer KV structure."),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The outer layer Redis Key like ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-2")," is no different from keys in single-view cache.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The inner layer Hash Key, also called SubKey in Jimmer, is the parameter of global filters."),(0,i.kt)("p",{parentName:"li"},"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},'{"logicalDeleted":false}')," is provided by the built-in global filter of logical delete, indicating the cached value is not the collection of ids of all associated objects, but only the ids of those undeleted associated objects.")))),(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Undoubtedly, if the cached data in Redis is not cleared due to timeout, executing the above Java/Kotlin code again will directly return the association data from Redis without generating related SQL."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Step 3: Convert id collection to associated objects"),(0,i.kt)("p",{parentName:"li"},"In the previous step, we obtained the collection of ids of the associated objects corresponding to the association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books"),". They are all undeleted objects.  "),(0,i.kt)("p",{parentName:"li"},"Now we can use the object cache of ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," type to convert the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," id collection to ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," collection. "),(0,i.kt)("p",{parentName:"li"},"This step is very simple and needs no discussion."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Step 4: Query ",(0,i.kt)("inlineCode",{parentName:"li"},"BookStore.avgPrice")," \u2777 via calculated cache ")),(0,i.kt)("p",{parentName:"li"},"The above code will obtain a list of aggregate root objects. If using the official sample data, there will be two aggregate root objects with ",(0,i.kt)("inlineCode",{parentName:"p"},"ID")," of 1 and 2."),(0,i.kt)("p",{parentName:"li"},"Jimmer first looks up the data in Redis with keys ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-2"),"."),(0,i.kt)("p",{parentName:"li"},"Assuming the data for these keys cannot be found in Redis"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"127.0.0.1:6379> keys BookStore.avgPrice-* \n(empty array)\n")),(0,i.kt)("p",{parentName:"li"},"Then the following SQL is executed to compute the calculated property"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID,\n    avg(tb_2_.PRICE)\nfrom BOOK_STORE tb_1_\nleft join BOOK tb_2_\n    on tb_1_.ID = tb_2_.STORE_ID\nwhere\n        tb_1_.ID in (\n            ? /* 1 */, ? /* 2 */  \n        )\n    and\n        // highlight-next-line\n        tb_1_.DELETED = ? /* false */\ngroup by \n    tb_1_.ID\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The filtering condition ",(0,i.kt)("inlineCode",{parentName:"p"},"tb_1_.DELETED = false")," comes from the built-in global filter of logical delete.")),(0,i.kt)("p",{parentName:"li"},"Jimmer will put the query results into Redis, so we can view the data in Redis:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'127.0.0.1:6379> keys BookStore.avgPrice-*\n1) "BookStore.avgPrice-2"  \n2) "BookStore.avgPrice-1"\n\n127.0.0.1:6379> hgetall BookStore.avgPrice-1\n# highlight-next-line\n1) "{\\"logicalDeleted\\":false}"\n2) "59.333333"\n\n127.0.0.1:6379> hgetall BookStore.avgPrice-2\n# highlight-next-line \n1) "{\\"logicalDeleted\\":false}"\n2) "80.5" \n127.0.0.1:6379>\n')),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The multi-view cache uses Redis Hash structure, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"hgetall")," command is needed instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),"."),(0,i.kt)("p",{parentName:"admonition"},"Redis Hash is a nested two-layer KV structure.  "),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The outer layer Redis Key like ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-2")," is no different from keys in single-view cache.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The inner layer Hash Key, also called SubKey in Jimmer, is the parameter of global filters."))),(0,i.kt)("p",{parentName:"admonition"},"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},'{"logicalDeleted":false}')," is provided by the built-in global filter of logical delete, indicating the cached value depends on the undeleted associated data rather than all associated data.")),(0,i.kt)("p",{parentName:"li"},"Thus, the two ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore")," objects can obtain the average prices of their respective undeleted books via the calculated property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice"),"."),(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Undoubtedly, if the cached data in Redis is not cleared due to timeout, executing the above Java/Kotlin code again will directly return the calculated data from Redis without generating related SQL.")))),(0,i.kt)("p",null,"Finally, Jimmer concatenates the results of the 4 steps as the final data returned to the user."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id":1,\n        "name":"O\'REILLY",\n        "website":null,\n        // highlight-next-line\n        "books":[\n            {\n                "id":6,\n                "name":"Effective TypeScript", \n                "edition":3,\n                "price":88\n            },\n            {\n                "id":5,\n                ...omitted...\n            },\n            {\n                "id":3,\n                ...omitted...\n            },\n            {\n                "id":2,\n                ...omitted...\n            },\n            {\n                "id":9,\n                ...omitted...\n            },\n            {\n                "id":8,\n                ...omitted...\n            }\n        ],\n        // highlight-next-line\n        "avgPrice":59.333333,\n    },\n    {\n        "id":2,\n        "name":"MANNING",\n        "website":null,\n        // highlight-next-line\n        "books":[\n            {\n                "id":12,\n                "name":"GraphQL in Action",\n                "edition":3,\n                "price":80\n            },\n            {\n                "id":11,\n                ...omitted...\n            }\n        ],\n        "avgPrice":80.5\n    }\n]\n')),(0,i.kt)("h3",{id:"adjust-filtering-behavior"},"Adjust Filtering Behavior"),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"../../query/global-filter/logical-deleted"},"Logical Delete")," documentation, we introduced that the logical delete filter can be ignored or even reversed."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Ignore filtering behavior"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookTable table = BookTable.$;\n\nList<Book> books = sqlClient\n    .filters(cfg -> {\n        // highlight-next-line\n        cfg.disable(\n            cfg\n                .getFilterManager()\n                .builtIns()\n                .getDeclaredNotDeletedFilter(Book.class)\n        ); \n    })\n    .createQuery(table)\n    .select(table)\n    .execute();\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .filters {\n        // highlight-next-line \n        disable(\n            filterManager\n                .builtIns\n                .getDeclaredNotDeletedFilter(Book::class)\n        )\n    }\n    .createQuery(table)\n    .select(table)\n    .execute() \n")))),(0,i.kt)("p",{parentName:"li"},"After executing the code, if the cached information entered in the previous example has not been cleared, the latest data in Redis should be:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'127.0.0.1:6379> keys BookStore.books-*\n1) "BookStore.books-2"\n2) "BookStore.books-1"\n\n127.0.0.1:6379> hgetall BookStore.books-1\n1) "{\\"logicalDeleted\\":false}"\n2) "[6,5,3,2,9,8]"\n# highlight-next-line\n3) "{}"\n4) "[6,5,4,3,2,1,9,8,7]"\n\n127.0.0.1:6379> hgetall BookStore.books-2\n1) "{\\"logicalDeleted\\":false}"\n2) "[12,11]" \n# highlight-next-line\n3) "{}"\n4) "[12,11,10]"\n\n127.0.0.1:6379> keys BookStore.avgPrice-*\n1) "BookStore.avgPrice-2"\n2) "BookStore.avgPrice-1"\n\n127.0.0.1:6379> hgetall BookStore.avgPrice-1\n1) "{\\"logicalDeleted\\":false}"\n2) "59.333333"\n# highlight-next-line\n3) "{}"\n4) "58.5"\n\n127.0.0.1:6379> hgetall BookStore.avgPrice-2 \n1) "{\\"logicalDeleted\\":false}"\n2) "80.5"\n# highlight-next-line\n3) "{}"\n4) "8.333333"\n')),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The outer layer Redis Keys like ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-2")," are no different from keys in single-view cache.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The inner layer Hash Keys, also called SubKeys in Jimmer, are the parameters of transient resolvers. "),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"{}")," is the corresponding SubKey for this example, and the corresponding cached value is the data when the filter is ignored. This is also what we see in the documentation about single-view cache.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Reverse filtering behavior"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookTable table = BookTable.$;\n\nList<Book> books = sqlClient\n    .filters(cfg -> {\n        // highlight-next-line\n        cfg.disable(\n            cfg\n                .getFilterManager()\n                .builtIns()\n                .getDeclaredNotDeletedFilter(Book.class)\n        );\n        // highlight-next-line \n        cfg.enable(\n            cfg\n                .getFilterManager()\n                .builtIns()\n                .getDeclaredAlreadyDeletedFilter(Book.class)\n        );\n    })\n    .createQuery(table)\n    .select(table)\n    .execute();\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .filters {\n        // highlight-next-line\n        disable(\n            filterManager\n                .builtIns\n                .getDeclaredNotDeletedFilter(Book::class)\n        )\n        // highlight-next-line\n        enable(\n            cfg\n                .getFilterManager()\n                .builtIns()\n                .getDeclaredAlreadyDeletedFilter(Book.class)\n        )\n    }\n    .createQuery(table)\n    .select(table)\n    .execute()\n")))),(0,i.kt)("p",{parentName:"li"},"After executing the code, if the cached information entered in the previous example has not been cleared, the latest data in Redis should be:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'127.0.0.1:6379> keys BookStore.books-*\n1) "BookStore.books-2"\n2) "BookStore.books-1"\n\n127.0.0.1:6379> hgetall BookStore.books-1\n1) "{}"\n2) "[6,5,4,3,2,1,9,8,7]"\n3) "{\\"logicalDeleted\\":false}"\n4) "[6,5,3,2,9,8]"\n# highlight-next-line\n5) "{\\"logicalDeleted\\":true}"\n6) "[4,1,7]"\n\n127.0.0.1:6379> hgetall BookStore.books-2\n1) "{}"\n2) "[12,11,10]"\n3) "{\\"logicalDeleted\\":false}"\n4) "[12,11]"\n# highlight-next-line\n5) "{\\"logicalDeleted\\":true}"\n6) "[10]"\n\n127.0.0.1:6379> keys BookStore.avgPrice-*\n1) "BookStore.avgPrice-2"\n2) "BookStore.avgPrice-1"\n\n127.0.0.1:6379> hgetall BookStore.avgPrice-1\n3) "{}"\n4) "58.5"\n1) "{\\"logicalDeleted\\":false}"\n2) "59.333333" \n# highlight-next-line\n1) "{\\"logicalDeleted\\":true}"\n2) "56.833333"\n\n127.0.0.1:6379> hgetall BookStore.avgPrice-2\n3) "{}"\n4) "8.333333"\n1) "{\\"logicalDeleted\\":false}"\n2) "80.5"\n# highlight-next-line\n1) "{\\"logicalDeleted\\":true}"\n2) "80"\n')),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The outer layer Redis Keys like ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-2")," are no different from keys in single-view cache.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The inner layer Hash Keys, also called SubKeys in Jimmer, are the parameters of global filters."),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'{"logicalDeleted":true}')," is the corresponding SubKey for this example, indicating the cached value depends on the deleted associated data rather than all associated data, which is the opposite of the default filtering logic."))),(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Readers can take a close look at these ",(0,i.kt)("inlineCode",{parentName:"p"},"redis-cli")," commands and easily find that the data of SubKey ",(0,i.kt)("inlineCode",{parentName:"p"},'{"logicalDeleted":false}')," merged with the data of SubKey ",(0,i.kt)("inlineCode",{parentName:"p"},'{"logicalDeleted":true}')," is exactly the data of SubKey ",(0,i.kt)("inlineCode",{parentName:"p"},"{}"),".")))),(0,i.kt)("h2",{id:"consistency"},"Consistency"),(0,i.kt)("p",null,"Now let's modify the logical delete flag of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," object with id 6."),(0,i.kt)("p",null,"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"Book-6")," belongs to ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore-1"),", it is foreseeable that the multi-view caches corresponding to the properties ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books-1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice-1")," will definitely be invalidated."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If BinLog trigger is enabled, modifying the database in any way can lead to Jimmer's cache consistency involvement. For example, directly executing the following SQL in SQL IDE"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK  \nset DELETED = true\nwhere ID = 6;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If only Transaction trigger is enabled, the database must be modified using Jimmer's API"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient.deleteById(Book.class, 6L, DeleteMode.LOGICAL)\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient.deleteById(Book::class, 6L, DeleteMode.LOGICAL)\n")))),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," entity is configured with a logical delete field, the default delete policy is logical delete. So the ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteMode.LOGICAL")," above can actually be omitted. It is written explicitly here just for emphasis.")))),(0,i.kt)("p",null,"No matter which way above is used to modify the data, you will see the following log output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Delete data from redis: [Book-6] \u2776\nDelete data from redis: [Author.books-3] \u2777\nDelete data from redis: [BookStore.books-1] \u2778\nDelete data from redis: [BookStore.avgPrice-1] \u2779\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 Update object cache of modified entity ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 Any association property targeting ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," must be affected, of course including ",(0,i.kt)("inlineCode",{parentName:"p"},"Author.books")),(0,i.kt)("p",{parentName:"li"},"According to existing database data, the affected ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," object id is 3")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2778 Any association property targeting ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," must be affected, of course including ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books")),(0,i.kt)("p",{parentName:"li"},"According to existing database data, the affected ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore")," object id is 1  ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2779 The calculated cache ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore")," object with id 1 is also affected. This is the most amazing characteristic. "),(0,i.kt)("p",{parentName:"li"},"If you have forgotten the specific logic of this code, you can review the following code in the ",(0,i.kt)("a",{parentName:"p",href:"../cache-type/calculation"},"Calculated Cache")," documentation:"),(0,i.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@EventListener\nfun onAssociationChange(e: AssociationEvent) {\n    if (sqlClient.caches.isAffectedBy(e) && \n        // highlight-next-line\n        e.isChanged(BookStore::books)\n    ) {\n        ...code omitted...\n    }\n}\n")))),(0,i.kt)("p",{parentName:"li"},"If you focus on the highlighted line, this calculated property cares about changes to the association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books"),"."),(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Modifying the association field between tables is not the only way to trigger association change events. Modifying the filtered field in associated objects, ",(0,i.kt)("em",{parentName:"p"},"like ",(0,i.kt)("inlineCode",{parentName:"em"},"DELETED")," here"),", can also trigger association change events.  "),(0,i.kt)("p",{parentName:"admonition"},"This is a very important characteristic of Jimmer's trigger mechanism!")),(0,i.kt)("p",{parentName:"li"},"It is obvious that \u2778 has already sensed the change of association property ",(0,i.kt)("inlineCode",{parentName:"p"},"BookStore.books"),", so it will further lead to the invalidation of the calculated cache here."))))}u.isMDXComponent=!0}}]);