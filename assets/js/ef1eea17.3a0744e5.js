"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[3003],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(t),m=l,b=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(b,i(i({ref:n},p),{},{components:t})):a.createElement(b,i({ref:n},p))}));function m(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var o=t.length,i=new Array(o);i[0]=u;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,i[1]=r;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(67294),l=t(34334);const o="tabItem_Ymn6";function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(o,i),hidden:t},n)}},65488:(e,n,t)=>{t.d(n,{Z:()=>m});var a=t(83117),l=t(67294),o=t(34334),i=t(72389),r=t(67392),s=t(7094),c=t(12466);const p="tabList__CuJ",d="tabItem_LNqP";function u(e){var n;const{lazy:t,block:i,defaultValue:u,values:m,groupId:b,className:k}=e,h=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=m??h.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),f=(0,r.l)(g,((e,n)=>e.value===n.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const N=null===u?u:u??(null==(n=h.find((e=>e.props.default)))?void 0:n.props.value)??h[0].props.value;if(null!==N&&!g.some((e=>e.value===N)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${N}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:I}=(0,s.U)(),[v,T]=(0,l.useState)(N),_=[],{blockElementScrollPositionUntilNextRender:O}=(0,c.o5)();if(null!=b){const e=y[b];null!=e&&e!==v&&g.some((n=>n.value===e))&&T(e)}const j=e=>{const n=e.currentTarget,t=_.indexOf(n),a=g[t].value;a!==v&&(O(n),T(a),null!=b&&I(b,String(a)))},w=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=_.indexOf(e.currentTarget)+1;t=_[n]??_[0];break}case"ArrowLeft":{const n=_.indexOf(e.currentTarget)-1;t=_[n]??_[_.length-1];break}}null==(n=t)||n.focus()};return l.createElement("div",{className:(0,o.Z)("tabs-container",p)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},k)},g.map((e=>{let{value:n,label:t,attributes:i}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:v===n?0:-1,"aria-selected":v===n,key:n,ref:e=>_.push(e),onKeyDown:w,onFocus:j,onClick:j},i,{className:(0,o.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":v===n})}),t??n)}))),t?(0,l.cloneElement)(h.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},h.map(((e,n)=>(0,l.cloneElement)(e,{key:n,hidden:e.props.value!==v})))))}function m(e){const n=(0,i.Z)();return l.createElement(u,(0,a.Z)({key:String(n)},e))}},32102:(e,n,t)=>{t.d(n,{s:()=>k});var a=t(83117),l=t(67294),o=t(42293),i=t(50657),r=t(6514),s=t(54776),c=t(10155),p=t(15861),d=t(93946),u=t(9137),m=t(61274),b=t(50594);const k=(0,l.memo)((e=>{let{open:n,fullScreen:t=!1,title:a,onClose:s,children:k}=e;const[g,f]=(0,l.useState)(t),N=(0,l.useCallback)((()=>{f((e=>!e))}),[]);return l.createElement(i.Z,{open:n,onClose:s,fullScreen:g,TransitionComponent:h,maxWidth:"md"},l.createElement(o.Z,{sx:{position:"relative"}},l.createElement(c.Z,null,l.createElement(p.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},a),l.createElement(d.Z,{onClick:N,style:{color:"white"}},g?l.createElement(m.Z,null):l.createElement(u.Z,null)),l.createElement(d.Z,{"aria-label":"close",onClick:s,style:{color:"white"}},l.createElement(b.Z,null)))),l.createElement(r.Z,null,k))})),h=l.forwardRef((function(e,n){return l.createElement(s.Z,(0,a.Z)({direction:"up",ref:n},e))}))},39511:(e,n,t)=>{t.d(n,{b:()=>i});var a=t(67294),l=t(83321),o=t(32102);const i=(0,a.memo)((e=>{let{buttonText:n,fullScreen:t=!1,title:i=n,children:r}=e;const[s,c]=(0,a.useState)(!1),p=(0,a.useCallback)((e=>{c(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),d=(0,a.useCallback)((()=>{c(!1)}),[]);return a.createElement(a.Fragment,null,a.createElement(l.Z,{"data-is-view-more-button":"true",onClick:p,variant:"outlined",size:"small"},n),a.createElement(o.s,{open:s,onClose:d,title:i,fullScreen:t},r))}))},17222:(e,n,t)=>{t.d(n,{ZP:()=>i});var a=t(83117),l=(t(67294),t(3905));const o={toc:[{value:"Scene-1",id:"scene-1",level:2},{value:"Scene-2",id:"scene-2",level:2}]};function i(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Currently, other technologies that operate on SQL, whether ORM or non-ORM, have a blank area: they only consider dynamic ",(0,l.kt)("inlineCode",{parentName:"p"},"where"),", and do not consider ",(0,l.kt)("inlineCode",{parentName:"p"},"dynamic join"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Dynamic JOIN")," is defined as: If some dynamic query conditions are for tables other than the current table. This means"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"When the condition is met: First join to other tables through association properties, then add dynamic where conditions to the joined table")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"When the condition is not met: Cannot join other tables through association properties"))),(0,l.kt)("h2",{id:"scene-1"},"Scene-1"),(0,l.kt)("p",null,"Let's first look at the first scene, taking MyBatis oriented to native SQL as an example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define MyBatis Mapper interface"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Mapper\npublic interface BookMapper {\n\n    List<Book> findBooks(\n        @Nullable String name,\n        @Nullable String storeName, \n        @Nullable String storeWebsite\n    );\n}\n")),(0,l.kt)("p",{parentName:"li"},"Here, all query parameters may be null, which is clearly a dynamic query."),(0,l.kt)("p",{parentName:"li"},"The last two query parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"storeWebsite"),", their filtering conditions are not applied on the current table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK"),", but on the parent table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_STORE"),".\nThat is, when any of these two parameters is non-null, a JOIN to the ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_STORE")," table will be generated. This table join dynamically determined by the parameter value is referred to as ",(0,l.kt)("inlineCode",{parentName:"p"},"dynamic JOIN")," in this article.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define MyBatis SQL mapping XML"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="somepackage.BookMapper">\n    <select id="findBooks" resultType="somepackage.Book">\n        select * from BOOK as book\n        \x3c!-- highlight-next-line --\x3e\n        <if test="storeName != null or storeWebsite != null"> \u2776\n            inner join BOOK_STORE as store\n                on book.STORE_ID = store.ID\n        </if>\n        <where>\n            <if test="name != null">\n                and book.NAME = #{name}\n            </if>\n            <if test="storeName != null"> \u2777\n                and store.NAME = #{storeName}\n            </if>\n            <if test="storeWebsite != null">\n                and store.WEBSITE = #{storeWebsite} \u2778\n            </if>\n        </where>\n    </select>\n</mapper>\n')),(0,l.kt)("p",{parentName:"li"},"Here, \u2776 is the dynamic JOIN. However, for developers, \u2777 and \u2778 are the purpose, and \u2776 is the work that has to be done to support \u2777 and \u2778. Its judgment condition is a burden."),(0,l.kt)("p",{parentName:"li"},"You may have noticed that \u2776 uses ",(0,l.kt)("inlineCode",{parentName:"p"},"or"),". This is easy to understand."),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"However, this is only the simplest dynamic connection between two tables. For deeper multi-table join operations, the complexity of dynamic connections will increase dramatically!")))),(0,l.kt)("h2",{id:"scene-2"},"Scene-2"),(0,l.kt)("p",null,"Let's take a look at the second scene. With the previous example as the basis, this example is decoupled from any business."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="somepackage.AMapper">\n  <select id="findAObjects" resultType="somepackage.A">\n    select distinct A.id\n    from A\n    \x3c!-- highlight-start --\x3e  \n    <if test="bId != null or cId != null or dId != null or eId != null">\n      inner join B on A.ID = B.A_ID \n    </if>\n    <if test="cId != null or dId != null or eId != null">\n      inner join C on B.ID = C.B_ID\n    </if>\n    <if test="dId != null or eId != null">\n      inner join D on C.ID = D.C_ID \n    </if>\n    <if test="eId != null">\n      inner join E on D.ID = E.D_ID\n    </if>\n    \x3c!-- highlight-end --\x3e\n    <where>\n      <if test="aId != null">\n        and A.ID = #{aId}  \n      </if>\n      <if test="bId != null">\n        and B.ID = #{bId}\n      </if>\n      <if test="cId != null">\n        and C.ID = #{cId}\n      </if>\n      <if test="dId != null">\n        and D.ID = #{dId}\n      </if>\n      <if test="eId != null">\n        and E.ID = #{eId}\n      </if>\n    </where>\n  </select>\n</mapper>\n')),(0,l.kt)("p",null,"The logic of this example is simple. The five tables A, B, C, D and E form a JOIN chain, and each table has a dynamic query condition. However, as you can see, the complexity of dynamic JOIN has become unacceptable."))}i.isMDXComponent=!0},42720:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>k,frontMatter:()=>c,metadata:()=>d,toc:()=>m});var a=t(83117),l=(t(67294),t(3905)),o=t(17222),i=t(65488),r=t(85162),s=t(39511);const c={sidebar_position:4,title:"Optimize Unnecessary Joins"},p=void 0,d={unversionedId:"query/dynamic-join/optimization",id:"query/dynamic-join/optimization",title:"Optimize Unnecessary Joins",description:"Usage",source:"@site/docs/query/dynamic-join/optimization.mdx",sourceDirName:"query/dynamic-join",slug:"/query/dynamic-join/optimization",permalink:"/jimmer/docs/query/dynamic-join/optimization",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/query/dynamic-join/optimization.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Optimize Unnecessary Joins"},sidebar:"tutorialSidebar",previous:{title:"Merge Conflict Joins",permalink:"/jimmer/docs/query/dynamic-join/merge"},next:{title:"Pagination Safety",permalink:"/jimmer/docs/query/dynamic-join/table-ex"}},u={},m=[{value:"Usage",id:"usage",level:2},{value:"Basic Concepts",id:"basic-concepts",level:3},{value:"Another Solution",id:"another-solution",level:3},{value:"Ghost Joins",id:"ghost-joins",level:2},{value:"Half Joins",id:"half-joins",level:2}],b={toc:m};function k(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},b,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"usage"},"Usage"),(0,l.kt)("h3",{id:"basic-concepts"},"Basic Concepts"),(0,l.kt)("p",null,"In Jimmer SQL DSL, created join objects that are not used will be ignored. For example:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable table = BookTable.$;\n\n// highlight-next-line\nSystem.out.println("Unsed join: " + table.store());\n\nList<Book> books = sqlClient\n    .createQuery(table) \n    .orderBy(table.name().asc(), table.edition().desc())\n    .select(table)\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        \n        // highlight-next-line\n        println("Unsed join: ${table.store}")\n\n        orderBy(table.name.asc(), table.edition.desc())\n        select(table)\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"Although a JOIN object is created via ",(0,l.kt)("inlineCode",{parentName:"p"},"table.store"),", since it is not used by the SQL DSL of the current query, this JOIN object will be ignored."),(0,l.kt)("p",null,"Therefore, the final generated SQL will not contain any JOIN operations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME, \n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_ \nwhere tb_1_.NAME = ?\n")),(0,l.kt)("h3",{id:"another-solution"},"Another Solution"),(0,l.kt)("p",null,"In ",(0,l.kt)(s.b,{buttonText:"Problems with current solutions",mdxType:"ViewMore"},(0,l.kt)(o.ZP,{mdxType:"DynamicJoinProblem"})),", we listed two scenarios. "),(0,l.kt)("p",null,"In the ",(0,l.kt)("a",{parentName:"p",href:"./merge"},"previous doc"),", we discussed solving these two scenarios by utilizing Jimmer SQL DSL's automatic merge of conflicting joins."),(0,l.kt)("p",null,"Here, we use another approach to solve the same problems."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Solve the problem in scenario 1:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> findBooks(\n        @Nullable String name,\n        @Nullable String storeName,\n        @Nullable String storeWebsite\n) {\n    BookTable table = BookTable.$;\n\n    // Create JOIN object unconditionally first,  \n    // will be auto ignored if not used later,\n    // so no useless JOIN\n    // highlight-next-line \n    BookStoreTable store = table.store();\n\n    return sqlClient\n        .createQuery(table)\n        .whereIf(\n            name != null,\n            () -> book.name().like(name)\n        )\n        .whereIf(\n            storeName != null, \n            () -> store.name().like(storeName)\n        )\n        .whereIf(\n            storeWebsite != null,\n            () -> store.website().like(storeWebsite)\n        )\n        .select(book)\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findBooks(\n    name: String? = null,\n    storeName: String? = null,\n    storeWebsite: String? = null\n): List<Book> {\n    return sqlClient\n        .createQuery(Book::class) {\n            \n            // Create JOIN object unconditionally first,\n            // will be auto ignored if not used later, \n            // so no useless JOIN\n            // highlight-next-line\n            val store = table.store\n            \n            name?.let {\n                where(table.name like it)\n            } \n            storeName?.let {\n                where(store.name like it) \n            }\n            storeWebsite?.let {\n                where(store.website like it)\n            }\n            select(table)\n        }\n        .execute()\n}\n")))),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If only ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," is specified, without ",(0,l.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"storeWebsite"),", then ",(0,l.kt)("inlineCode",{parentName:"p"},"store")," is a created but unused join object, thus ignored. The final generated SQL contains no joins."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere tb_1_.NAME = ?\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If ",(0,l.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"storeWebsite")," are specified, ",(0,l.kt)("inlineCode",{parentName:"p"},"store")," will be used, leading to join operations in the final generated SQL. This is obvious so no example here.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Solve the problem in scenario 2:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"List<Long> findDistinctIds(\n    @Nullable Long aId,\n    @Nullable Long bId,\n    @Nullable Long cId,\n    @Nullable Long dId,\n    @Nullable Long eId\n) {\n    ATable table = ATable.$;\n\n    // Create JOIN objects unconditionally first,\n    // Not used join objects will be auto ignored,\n    // so no useless JOIN objects \n    // highlight-start\n    BTableEx b = table.asTableEx().bs();\n    CTableEx c = b.cs();\n    DTableEx d = c.ds();\n    ETableEx e = d.es();\n    // highlight-end\n\n    return sqlClient\n        .createQuery(table)\n        .whereIf(\n            aId != null,\n            () -> table.id().like(aId)\n        )\n        .whereIf(\n            bId != null,  \n            () -> b.id().like(bId)\n        )\n        .whereIf(\n            cId != null,\n            () -> c.id().like(cId)\n        )\n        .whereIf(\n            dId != null,\n            () -> d.id().like(dId)\n        )\n        .whereIf(\n            eId != null,\n            () -> e.id().like(eId)\n        )\n        .select(book.id())\n        .distinct()\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findDistinctIds(\n    aId: Long? = null,\n    bId: Long? = null,\n    cId: Long? = null,\n    dId: Long? = null,\n    eId: Long? = null  \n): List<Long> {\n    \n    // Create JOIN object unconditionally first,\n    // will be auto ignored if not used later,\n    // so no useless JOIN\n    // highlight-start  \n    val b = table.asTableEx().bs\n    val c = b.cs\n    val d = c.ds\n    val e = d.es\n    // highlight-end\n\n    return sqlClient\n        .createQuery(A::class) {\n            aId?.let {\n                where(table.id eq it)\n            }\n            bId?.let {\n                where(b.id eq it)\n            }\n            cId?.let {\n                where(c.id eq it)  \n            }\n            dId?.let {\n                where(d.id eq it)\n            }\n            eId?.let {\n                where(e.id eq it)\n            }\n            select(table.id) \n        }\n        .distinct()\n        .execute()\n}\n")))),(0,l.kt)("admonition",{parentName:"li",type:"info"},(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Given the basics above, no need to list the generated SQL for different parameter combinations here. Just understand that the final SQL will not contain useless joins.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'When a JOIN object is used by the SQL DSL, it will be marked as "used" to prevent being ignored. This mark is transitive.'),(0,l.kt)("p",{parentName:"li"},"  For example: Marking ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),' as "used" will naturally also mark ',(0,l.kt)("inlineCode",{parentName:"p"},"c"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"table"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here (and various TableEx types in Java) is a concept to be introduced in later docs ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.")))))))),(0,l.kt)("h2",{id:"ghost-joins"},"Ghost Joins"),(0,l.kt)("p",null,"A ghost join is a simple optimization concept. It becomes clear when compared to a normal join: "),(0,l.kt)("p",null,"Let's look at an example of a normal table join first:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(book.store().name().eq("MANNING")) \n    .select(book)\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.store.name eq "MANNING")\n        select(table)\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"The generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE, \n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\n    /* highlight-start */ \n    inner join BOOK_STORE as tb_2_\n        on tb_1_.STORE_ID = tb_2_.ID\n    /* highlight-end */\nwhere\n    tb_2_.NAME = ?\n")),(0,l.kt)("p",null,"Now let's look at an example of a ghost join:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        .store()\n        // highlight-next-line\n        .id() // Access id only\n        .eq(2L)\n    )\n    .select(book)\n    .execute(); \n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            .store\n            // highlight-next-line\n            .id // Access id only\n            eq 2L\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"This time, the generated SQL: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere tb_1_.STORE_ID = ?  \n")),(0,l.kt)("p",null,"We see no table join in the SQL, only a condition ",(0,l.kt)("inlineCode",{parentName:"p"},"tb_1_.STORE_ID = ?")," based on the foreign key."),(0,l.kt)("p",null,"The reason: For a many-to-one association mapped by foreign key, the parent table's id is actually the child table's own foreign key. "),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("ol",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For a many-to-one association mapped by foreign key, if the associated object obtained via join operation accesses only the id field and no other fields, such join is considered a ghost join.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"The ghost join will be ignored and no related JOIN statement will be generated in the final SQL.")))),(0,l.kt)("h2",{id:"half-joins"},"Half Joins"),(0,l.kt)("p",null,"A half join is a concept similar to ghost join, but for join tables."),(0,l.kt)("p",null,"Let's first look at an example of a normal join table join:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Long> bookIds = sqlClient  \n    .createQuery(book)\n    .where(\n        book\n            .asTableEx()\n            .authors()\n            .firstName()\n            .eq("Alex") \n    )\n    .select(book.id())\n    .distinct()\n    .execute(); \n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                .asTableEx()\n                .authors\n                .firstName eq "Alex"\n        )\n        select(table.id)\n    }\n    .distinct() \n    .execute()\n')))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here (and various TableEx types in Java) is a concept to be introduced in later docs ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.  ")),(0,l.kt)("p",null,"The generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    distinct tb_1_.ID\nfrom BOOK as tb_1_  \n/* highlight-start */\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.BOOK_ID\ninner join AUTHOR as tb_3_ \n    on tb_2_.AUTHOR_ID = tb_3_.ID \n/* highlight-end */\nwhere tb_3_.FIRST_NAME = ?\n")),(0,l.kt)("p",null,"We see join tables produce two SQL JOIN clauses:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"First step: Join to intermediate table\n",(0,l.kt)("inlineCode",{parentName:"li"},"inner join BOOK_AUTHOR_MAPPING as tb_2_ on tb_1_.ID = tb_2_.BOOK_ID")),(0,l.kt)("li",{parentName:"ul"},"Second step: Join to target table\n",(0,l.kt)("inlineCode",{parentName:"li"},"inner join AUTHOR as tb_3_ on tb_2_.AUTHOR_ID = tb_3_.ID"))),(0,l.kt)("p",null,"Next, let's look at an example of a half join:"),(0,l.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Long> bookIds = sqlClient\n    .createQuery(book)\n    .where(\n        book\n            .asTableEx()\n            .authors()\n            // highlight-next-line\n            .id() // Access id only\n            .eq(2L)\n    )\n    .select(book.id())\n    .distinct()\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            (table as KNullableTableEx<Book>)\n                .authors\n                // highlight-next-line\n                .id // Access id only\n                eq 2L\n        )\n        select(table.id) \n    }\n    .distinct()\n    .execute() \n")))),(0,l.kt)("p",null,"This time, the generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    distinct tb_1_.ID\nfrom BOOK as tb_1_   \n/* highlight-start */\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.BOOK_ID  \n/* highlight-end */\nwhere tb_2_.AUTHOR_ID = ?\n")),(0,l.kt)("p",null,"This time we only see one SQL JOIN clause instead of two."),(0,l.kt)("p",null,"The reason: The target table's primary key is actually the foreign key from the intermediate table to the target table."),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("ol",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For associations mapped by join table, if the associated object obtained via join operation accesses only the id field and no other fields, such join is considered a half join.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"In the final generated SQL, a half join uses only one JOIN statement to join the intermediate table, without using second JOIN statement to further join the target table.")))))}k.isMDXComponent=!0}}]);