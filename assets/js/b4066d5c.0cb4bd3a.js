"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[9176],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=i,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||o;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},96361:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(83117),i=(n(67294),n(3905));const o={sidebar_position:1,title:"Problem"},r=void 0,s={unversionedId:"mutation/save-command/input-dto/problem",id:"mutation/save-command/input-dto/problem",title:"Problem",description:"In this article we discuss:",source:"@site/docs/mutation/save-command/input-dto/problem.mdx",sourceDirName:"mutation/save-command/input-dto",slug:"/mutation/save-command/input-dto/problem",permalink:"/jimmer/docs/mutation/save-command/input-dto/problem",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/mutation/save-command/input-dto/problem.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Problem"},sidebar:"tutorialSidebar",previous:{title:"Input DTO",permalink:"/jimmer/docs/mutation/save-command/input-dto/"},next:{title:"Lonely Form",permalink:"/jimmer/docs/mutation/save-command/input-dto/lonely"}},l={},p=[{value:"Problem of Dynamic Entities Parameters",id:"problem-of-dynamic-entities-parameters",level:2},{value:"Security Issue",id:"security-issue",level:3},{value:"API Ambiguity",id:"api-ambiguity",level:3},{value:"Solutions",id:"solutions",level:2},{value:"Comparison with GraphQLInput",id:"comparison-with-graphqlinput",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},m=u("Tabs"),c=u("TabItem"),d={toc:p};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this article we discuss:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The problem of using dynamic entities as method parameters ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Solutions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Comparison with ",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/graphql-js/mutations-and-input-types/"},"GraphQLInput")))),(0,i.kt)("h2",{id:"problem-of-dynamic-entities-parameters"},"Problem of Dynamic Entities Parameters"),(0,i.kt)("p",null,"Up to this point, we have systematically explained all the capabilities of save commands. "),(0,i.kt)("p",null,"Now we know that no matter what shape the data structure to be saved is, we can persist it to the database in one line of code calling save commands, with all internal details hidden. This is a very convenient low-level capability."),(0,i.kt)("p",null,"However, how should the upper layer APIs of business systems be designed? Should we directly accept dynamic objects via ",(0,i.kt)("inlineCode",{parentName:"p"},"@RequestBody"),"?"),(0,i.kt)(m,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'@PutMapping("/book")\npublic void saveBook(\n    // highlight-next-line\n    @RequestBody Book book\n) {\n    bookRepository.save(book);\n}\n'))),(0,i.kt)(c,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'@PutMapping("/book")\nfun saveBook(\n    // highlight-next-line\n    @RequestBody book: Book\n) {\n    bookRepository.save(book)\n} \n')))),(0,i.kt)("p",null,"This code can work, allowing HTTP clients to submit data structures of arbitrary shapes. This seems to be an extremely powerful capability. "),(0,i.kt)("p",null,"However, this approach has two problems:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Security issue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"API ambiguity"))),(0,i.kt)("h3",{id:"security-issue"},"Security Issue"),(0,i.kt)("p",null,"The client is granted too much power, being able to submit very deep and wide tree-shaped data structures that far exceed its allowed scope of modification under current security policies. This is a huge security vulnerability. "),(0,i.kt)("p",null,"For example, the client can totally submit data like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "name": "SQL in Motion", \n    "edition": 1,\n    "price": 41.99,\n    "store":{\n        "name": "MANNING",\n        "location": {\n            "city": "Vancouver",\n            "country": "Canada",\n            ...\n        }\n    },\n    "authors":[\n        {\n            "firstName": "Ben",\n            "lastName": "Brumm", \n            "job":{\n                "company": {\n                    "name": "IBM"\n                },\n                "title": "Senior HR Manager",\n                ...\n            }\n            ...\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"Assume your intention in providing this HTTP API is that only the ",(0,i.kt)("inlineCode",{parentName:"p"},"BOOK"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BOOK_STORE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"AUTHOR")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," tables can be affected. "),(0,i.kt)("p",null,"However, now the scope of data submitted by the client is too large, with far greater destructive power than you anticipated. In the above example, there are at least 4 unexpected destructions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"<root>.store.location.city")," is modified from ",(0,i.kt)("inlineCode",{parentName:"p"},"New York")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Vancouver")," ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"<root>.store.location.country")," is modified from ",(0,i.kt)("inlineCode",{parentName:"p"},"USA")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Canada"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"<root>.authors[0].job.company")," is modified from ",(0,i.kt)("inlineCode",{parentName:"p"},"NAB")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"IBM")," ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"<root>.authors[0].job.title")," is modified from ",(0,i.kt)("inlineCode",{parentName:"p"},"Senior Business Analyst")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Senior HR Manager")))),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"@RequestBody")," to directly accept dynamic objects as input parameters in external APIs is very dangerous and will lead to serious security issues."),(0,i.kt)("p",{parentName:"admonition"},"Therefore, save commands must be sealed internally as a low-level capability, and their raw capabilities must absolutely not be directly exposed through HTTP APIs.")),(0,i.kt)("h3",{id:"api-ambiguity"},"API Ambiguity"),(0,i.kt)("p",null,"Using dynamic objects as parameters leads to ambiguity in the API. Client developers do not know which fields are decided automatically by the business system and which must be specified by themselves, so they do not know how to invoke the API properly."),(0,i.kt)("p",null,"This issue is especially obvious for insert operations. Unlike update operations which can modify just a few properties, insert operations often need to specify many properties, otherwise exceptions will occur. Client developers are unclear about exactly which properties must be specified to avoid errors. "),(0,i.kt)("h2",{id:"solutions"},"Solutions"),(0,i.kt)("p",null,"To resolve this issue, Jimmer provides three solutions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"./lonely"},"Lonely Form")),(0,i.kt)("admonition",{parentName:"li",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This is a very crude solution, only for learning or very simple projects.")),(0,i.kt)("p",{parentName:"li"},"This solution only handles data persistence operations on a single table, and only resolves the security issue rather than the API ambiguity issue."),(0,i.kt)("p",{parentName:"li"},"It is also the only solution that does not require defining Input DTOs.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"./dto-lang"},"Auto-Generated Input DTOs via DTO Language")),(0,i.kt)("p",{parentName:"li"},"This solution quickly auto-generates Input DTOs with very little cost."),(0,i.kt)("p",{parentName:"li"},"It is a complete and extremely convenient solution, so is the recommended approach. Its huge convenience advantage will be introduced later."),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"All built-in examples use this solution."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"./mapstruct"},"Manual Input DTOs via MapStruct")),(0,i.kt)("p",{parentName:"li"},"This solution requires developers to manually create Input DTOs and handle conversion to dynamic objects."),(0,i.kt)("p",{parentName:"li"},"It is absolutely flexible, but requires a lot of work from developers."))),(0,i.kt)("h2",{id:"comparison-with-graphqlinput"},"Comparison with GraphQLInput"),(0,i.kt)("p",null,"The above introduces three solutions. Among them, although the latter two solutions differ greatly, they share one commonality - relying on Input DTOs. "),(0,i.kt)("p",null,"Comparing Jimmer's Input DTOs with ",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/graphql-js/mutations-and-input-types/"},"GraphQLInput"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Similarities"),(0,i.kt)("p",{parentName:"li"},"In GraphQL, query results are GraphQLObjects, i.e. dynamic objects of arbitrary shapes. However, if modification operations accept object parameters, they must be GraphQLInputs, i.e. static objects of fixed shapes. "),(0,i.kt)("p",{parentName:"li"},"GraphQLInput has exactly the same idea as InputDTO here, which is the inevitable design to resolve security issues - different routes leading to the same destination.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Differences"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"GraphQLInput is just a protocol, merely constraining that object parameters for modification operations must be static objects of fixed shapes."),(0,i.kt)("p",{parentName:"li"},"The benefit is not limiting specific implementation technologies. But the downside is saving business logic needs to be implemented by developers for every specific GraphQLInput shape. Tedious work still exists objectively, and developers can truly feel the pain of Input DTO explosion.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Jimmer's InputDTO is just an alternative representation of the dynamic entity to address security issues. Once the user finishes converting Input DTO to dynamic entity, the huge convenience of persisting arbitrary shaped data structures in one line of code via save commands can still be enjoyed. "),(0,i.kt)("p",{parentName:"li"},"If developers adopt the ",(0,i.kt)("a",{parentName:"p",href:"./dto-lang"},"Auto-Generated Input DTOs via DTO Language")," solution, Input DTO classes will be auto-generated, and the conversion logic between Input DTOs and dynamic entities will also be auto-generated. Thus the pain of Input DTO explosion no longer exists. So this is the recommended solution."))))))}h.isMDXComponent=!0}}]);