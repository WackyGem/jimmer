"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[7407],{31536:(e,t,a)=>{a.d(t,{Z:()=>I});var n=a(80102),i=a(83117),r=a(67294),l=a(10209),o=a(59766),p=a(94780),m=a(34867);const s=(0,a(70182).ZP)();var d=a(65149),u=a(39707),k=a(66500),c=a(95408),h=a(98700),N=a(85893);const g=["component","direction","spacing","divider","children","className","useFlexGap"],y=(0,k.Z)(),b=s("div",{name:"MuiStack",slot:"Root",overridesResolver:(e,t)=>t.root});function f(e){return(0,d.Z)({props:e,name:"MuiStack",defaultTheme:y})}function v(e,t){const a=r.Children.toArray(e).filter(Boolean);return a.reduce(((e,n,i)=>(e.push(n),i<a.length-1&&e.push(r.cloneElement(t,{key:`separator-${i}`})),e)),[])}const T=({ownerState:e,theme:t})=>{let a=(0,i.Z)({display:"flex",flexDirection:"column"},(0,c.k9)({theme:t},(0,c.P$)({values:e.direction,breakpoints:t.breakpoints.values}),(e=>({flexDirection:e}))));if(e.spacing){const n=(0,h.hB)(t),i=Object.keys(t.breakpoints.values).reduce(((t,a)=>(("object"==typeof e.spacing&&null!=e.spacing[a]||"object"==typeof e.direction&&null!=e.direction[a])&&(t[a]=!0),t)),{}),r=(0,c.P$)({values:e.direction,base:i}),l=(0,c.P$)({values:e.spacing,base:i});"object"==typeof r&&Object.keys(r).forEach(((e,t,a)=>{if(!r[e]){const n=t>0?r[a[t-1]]:"column";r[e]=n}}));const p=(t,a)=>{return e.useFlexGap?{gap:(0,h.NA)(n,t)}:{"& > :not(style) ~ :not(style)":{margin:0,[`margin${i=a?r[a]:e.direction,{row:"Left","row-reverse":"Right",column:"Top","column-reverse":"Bottom"}[i]}`]:(0,h.NA)(n,t)}};var i};a=(0,o.Z)(a,(0,c.k9)({theme:t},l,p))}return a=(0,c.dt)(t.breakpoints,a),a};var w=a(90948),C=a(71657);const x=function(e={}){const{createStyledComponent:t=b,useThemeProps:a=f,componentName:o="MuiStack"}=e,s=t(T),d=r.forwardRef((function(e,t){const r=a(e),d=(0,u.Z)(r),{component:k="div",direction:c="column",spacing:h=0,divider:y,children:b,className:f,useFlexGap:T=!1}=d,w=(0,n.Z)(d,g),C={direction:c,spacing:h,useFlexGap:T},x=(0,p.Z)({root:["root"]},(e=>(0,m.Z)(o,e)),{});return(0,N.jsx)(s,(0,i.Z)({as:k,ownerState:C,ref:t,className:(0,l.Z)(x.root,f)},w,{children:y?v(b,y):b}))}));return d}({createStyledComponent:(0,w.ZP)("div",{name:"MuiStack",slot:"Root",overridesResolver:(e,t)=>t.root}),useThemeProps:e=>(0,C.Z)({props:e,name:"MuiStack"})}),I=x},20036:(e,t,a)=>{a.d(t,{k:()=>y});var n=a(52263),i=a(94054),r=a(33841),l=a(23599),o=a(90629),p=a(43246),m=a(31536),s=a(61903),d=a(50657),u=a(37645),k=a(6514),c=a(31425),h=a(58951),N=a(83321),g=a(67294);const y=(0,g.memo)((()=>{const[e,t]=(0,g.useState)((()=>({name:"Learning GraphQL",edition:1,price:45,storeId:1,authorIds:[1,2]}))),a=(0,g.useCallback)((e=>{t((t=>({...t,name:e.target.value})))}),[]),y=(0,g.useCallback)((e=>{t((t=>({...t,edition:e.target.valueAsNumber})))}),[]),b=(0,g.useCallback)((e=>{t((t=>({...t,price:e.target.valueAsNumber})))}),[]),f=(0,g.useCallback)((e=>{let a;const n=e.target.value;a="string"==typeof n?parseInt(n):n,-1===a&&(a=void 0),t((e=>({...e,storeId:a})))}),[]),v=(0,g.useCallback)((e=>{let a=[];console.log(e.target.value);const n=e.target.value;a="string"==typeof n?n.split(",").map((e=>parseInt(e))):n,t((e=>({...e,authorIds:a})))}),[]),{i18n:T}=(0,n.Z)(),w=(0,g.useMemo)((()=>"zh"==T.currentLocale||"zh_cn"==T.currentLocale||"zh_CN"==T.currentLocale),[T.currentLocale]),[C,x]=(0,g.useState)(!1),I=(0,g.useCallback)((()=>{x(!0)}),[]),B=(0,g.useCallback)((()=>{x(!1)}),[]);return g.createElement(o.Z,{elevation:3,style:{padding:"1.5rem",width:500}},g.createElement(m.Z,{spacing:2},g.createElement("h1",null,"Book Form"),g.createElement(s.Z,{label:"Name",value:e.name,onChange:a,error:""===e.name,helperText:""===e.name?"Name is required":""}),g.createElement(s.Z,{label:"Edition",type:"number",value:e.edition,onChange:y}),g.createElement(s.Z,{label:"Price",type:"number",value:e.price,onChange:b}),g.createElement(i.Z,{fullWidth:!0},g.createElement(r.Z,{id:"store-select-label"},"Store"),g.createElement(p.Z,{labelId:"store-select-label",label:"Authors",value:e.storeId,onChange:f},g.createElement(l.Z,{value:-1},"--NONE--"),g.createElement(l.Z,{value:1},"O'REILLY"),g.createElement(l.Z,{value:2},"MANNING"))),g.createElement(i.Z,{fullWidth:!0},g.createElement(r.Z,{id:"author-multi-select-label"},"Authors"),g.createElement(p.Z,{multiple:!0,labelId:"author-multi-select-label",label:"Authors",value:e.authorIds,onChange:v},g.createElement(l.Z,{value:1},"Eve Procello"),g.createElement(l.Z,{value:2},"Alex Banks"),g.createElement(l.Z,{value:3},"Dan Vanderkam"),g.createElement(l.Z,{value:4},"Boris Cherny"),g.createElement(l.Z,{value:5},"Samer Buna"))),g.createElement(i.Z,null,g.createElement(N.Z,{onClick:I,variant:"contained"},"\u63d0\u4ea4"))),g.createElement(d.Z,{open:C,onClose:B},g.createElement(u.Z,null,w?"\u4fe1\u606f":"Info"),g.createElement(k.Z,null,g.createElement(h.Z,null,w?"\u4ec5\u4f5c\u793a\u8303\uff0c\u65e0\u4efb\u4f55\u6548\u679c":"For demonstration only, without any effect")),g.createElement(c.Z,null,g.createElement(N.Z,{onClick:B},"\u5173\u95ed"))))}))},32102:(e,t,a)=>{a.d(t,{s:()=>h});var n=a(83117),i=a(67294),r=a(42293),l=a(50657),o=a(6514),p=a(54776),m=a(10155),s=a(15861),d=a(93946),u=a(9137),k=a(61274),c=a(50594);const h=(0,i.memo)((e=>{let{open:t,fullScreen:a=!1,title:n,onClose:p,children:h}=e;const[g,y]=(0,i.useState)(a),b=(0,i.useCallback)((()=>{y((e=>!e))}),[]);return i.createElement(l.Z,{open:t,onClose:p,fullScreen:g,TransitionComponent:N,maxWidth:"md"},i.createElement(r.Z,{sx:{position:"relative"}},i.createElement(m.Z,null,i.createElement(s.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},n),i.createElement(d.Z,{onClick:b,style:{color:"white"}},g?i.createElement(k.Z,null):i.createElement(u.Z,null)),i.createElement(d.Z,{"aria-label":"close",onClick:p,style:{color:"white"}},i.createElement(c.Z,null)))),i.createElement(o.Z,null,h))})),N=i.forwardRef((function(e,t){return i.createElement(p.Z,(0,n.Z)({direction:"up",ref:t},e))}))},39511:(e,t,a)=>{a.d(t,{b:()=>l});var n=a(67294),i=a(83321),r=a(32102);const l=(0,n.memo)((e=>{let{buttonText:t,fullScreen:a=!1,title:l=t,children:o}=e;const[p,m]=(0,n.useState)(!1),s=(0,n.useCallback)((e=>{m(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),d=(0,n.useCallback)((()=>{m(!1)}),[]);return n.createElement(n.Fragment,null,n.createElement(i.Z,{"data-is-view-more-button":"true",onClick:s,variant:"outlined",size:"small"},t),n.createElement(r.s,{open:p,onClose:d,title:l,fullScreen:a},o))}))},34800:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>g,frontMatter:()=>d,metadata:()=>k,toc:()=>h});var n=a(83117),i=(a(67294),a(3905)),r=a(65488),l=a(85162),o=a(20036);const p={toc:[]};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The content of this article is only for Output DTOs, Input DTOs can freely adopt the flat scheme.")),(0,i.kt)("p",null,"For output, the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," mode is a controversial topic. The author disagrees with it, because"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The association model is not complex, it is not worth the system providing the necessary conversion logic")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This will cause the backend system and specific UI frontend to be tightly coupled, losing the universality it should have ",(0,i.kt)("em",{parentName:"p"},"(this is very important, will be discussed in detail later)")))),(0,i.kt)("p",null,"The deeper reason: Data structures with native associations are normalized data, while flattened objects processed by ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," are non-associated data."),(0,i.kt)("p",null,"However, you may be in a work situation like this: the frontend team you work with requires all query APIs to return flattened objects across the board, requires any attribute other than collection properties to be processed by ",(0,i.kt)("inlineCode",{parentName:"p"},"flat"),", and is very insistent."),(0,i.kt)("p",null,"Now let's explain why some frontend teams have this insistence. UI projects can be considered in two categories:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Projects that do not require state management"),(0,i.kt)("p",{parentName:"li"},"The biggest feature of such projects is that the functional areas on the interface ",(0,i.kt)("em",{parentName:"p"},"(excluding non-functional areas such as top bars and sidebars)")," adopt an overall switching mode ",(0,i.kt)("em",{parentName:"p"},"(which is more likely to happen on small-screen mobile devices)"),", so each UI interface is a data island."),(0,i.kt)("p",{parentName:"li"},"At this point, the main complexity of the project lies in UI rendering. Frontend developers do not need to care about data models at all."),(0,i.kt)("p",{parentName:"li"},"Since they don't care, the most natural idea is to expect the data structure to be exactly the same as the interface structure. For non-collection associations, the UI is usually displayed flatly, so there is a demand that all APIs return flattened objects.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Projects that require state management"),(0,i.kt)("p",{parentName:"li"},"The biggest feature of such projects is that there are decentralized, coexisting, and complex collaborative problems in the functional areas of the interface, so there are intricate connections between different UI components."),(0,i.kt)("p",{parentName:"li"},"At this point, the main complexity of the project lies in state management, and frontend developers must pay close attention to the structure of the data model."),(0,i.kt)("p",{parentName:"li"},"Frontend state management, to some extent, is the normalization or even relationalization of data. Large amounts of ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," data are destructive to such projects."))),(0,i.kt)("p",null,"If the frontend team has never experienced a UI project that requires state management, they will of course be unable to realize the importance of normalized data. At this time, they will form a habitual dependence on flat structures and refuse to accept other concepts that seem contrary to their own cognition but actually have no cost."),(0,i.kt)("p",null,"I mentioned earlier that excessive use of ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," mode will cause the backend system and specific UI frontend to be highly coupled. Let me think about a scenario:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The mobile UI was launched first. This UI application is very simple, each page is a data island, and no state management is required. Therefore, a large number of backend APIs are designed in a ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," style.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"As the system becomes more and more complex, a mobile user-facing application is not enough. An internal management system used by staff needs to be added. If the UI logic of this system is relatively complex, and is eventually determined to be a UI project that requires state management, the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," style backend APIs will be very difficult to handle. Either the backend develops another set of APIs that return normalized data, or the frontend writes a lot of code to restore the data back to normalized."))),(0,i.kt)("p",null,"It is possible to persuade by discussion, pointing out the importance of normalized data for state management, and pointing out that normalized data is not a problem for many UI libraries, such as ",(0,i.kt)("a",{parentName:"p",href:"https://ant.design/components/table#column"},"Antd Table.Column")," The type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"dataIndex")," attribute is ",(0,i.kt)("inlineCode",{parentName:"p"},"string | string[]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"string[]")," is support for hierarchical data that will not cause any development problems."),(0,i.kt)("p",null,"If you don't have a say in this or can't convince the other party, then you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," function to handle it."))}m.isMDXComponent=!0;var s=a(39511);const d={sidebar_position:1,title:"DTO Language"},u=void 0,k={unversionedId:"object/view/dto-language",id:"object/view/dto-language",title:"DTO Language",description:"1. Concepts",source:"@site/docs/object/view/dto-language.mdx",sourceDirName:"object/view",slug:"/object/view/dto-language",permalink:"/jimmer/docs/object/view/dto-language",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/object/view/dto-language.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"DTO Language"},sidebar:"tutorialSidebar",previous:{title:"DTO conversion",permalink:"/jimmer/docs/object/view/"},next:{title:"MapStruct",permalink:"/jimmer/docs/object/view/mapstruct"}},c={},h=[{value:"1. Concepts",id:"1-concepts",level:2},{value:"2. Create Files",id:"2-create-files",level:2},{value:"3. input, input-only modifiers",id:"3-input-input-only-modifiers",level:2},{value:"4. Simple Properties",id:"4-simple-properties",level:2},{value:"5. allScalars",id:"5-allscalars",level:2},{value:"6. Negative Properties",id:"6-negative-properties",level:2},{value:"7. Nullability",id:"7-nullability",level:2},{value:"7.1 <code>?</code>",id:"71-",level:3},{value:"7.2 <code>!</code>",id:"72-",level:3},{value:"8. Renaming",id:"8-renaming",level:2},{value:"8.1. Rename Single Property",id:"81-rename-single-property",level:3},{value:"8.2. Rename Multiple Properties",id:"82-rename-multiple-properties",level:3},{value:"9. Enum Mapping",id:"9-enum-mapping",level:2},{value:"10. Association Properties",id:"10-association-properties",level:2},{value:"10.1. Common Association",id:"101-common-association",level:3},{value:"10.2 Recursive Association",id:"102-recursive-association",level:3},{value:"10.3. id Function",id:"103-id-function",level:3},{value:"10.4. flat Function",id:"104-flat-function",level:3},{value:"11. Inheritance",id:"11-inheritance",level:2},{value:"12. Custom Properties",id:"12-custom-properties",level:2},{value:"12.1 Getting Started with Custom Properties",id:"121-getting-started-with-custom-properties",level:3},{value:"12.2 Built-in Types",id:"122-built-in-types",level:3},{value:"12.3 Generic Parameter Modifiers",id:"123-generic-parameter-modifiers",level:3},{value:"12.4 Import Statements",id:"124-import-statements",level:3},{value:"13. Annotations",id:"13-annotations",level:2},{value:"13.1 Basic Usage",id:"131-basic-usage",level:3},{value:"13.2 Annotation Override",id:"132-annotation-override",level:3},{value:"13.3 value Parameter",id:"133-value-parameter",level:3},{value:"12.4 Mix Java and Kotlin Syntax",id:"124-mix-java-and-kotlin-syntax",level:3},{value:"14. Practical Applications",id:"14-practical-applications",level:2}],N={toc:h};function g(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},N,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"1-concepts"},"1. Concepts"),(0,i.kt)("p",null,"The DTO language is a very powerful feature provided by Jimmer. It is a concept highly similar to ",(0,i.kt)("a",{parentName:"p",href:"../../query/object-fetcher"},"Object Fetcher"),", but at an earlier stage during compilation."),(0,i.kt)("p",null,"The DTO language is used to quickly define the shape of data structures. According to these shapes, DTOs can be compiled to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generate static DTO types corresponding to specific data structures")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generate conversion logic between DTO static objects and Jimmer dynamic objects")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generate ",(0,i.kt)("a",{parentName:"p",href:"../../query/object-fetcher"},"Object Fetchers")," defined by this shape"))),(0,i.kt)("p",null,"This approach is very efficient. It is tailored for Jimmer and much faster than using ",(0,i.kt)("a",{parentName:"p",href:"./mapstruct"},"mapstruct"),". It is the recommended way."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Even in some special scenarios where we cannot directly use unified ORM entities and have to use DTO objects, the development cost is only to define the shape of these DTOs. All other work ",(0,i.kt)("em",{parentName:"p"},"(DTO related Java/Kotlin definitions, conversion between DTOs and entities, interaction logic with database)")," is fully automated. You won't feel the pain of DTO explosion caused by traditional technical solutions at all.")),(0,i.kt)("h2",{id:"2-create-files"},"2. Create Files"),(0,i.kt)("p",null,"The code for the DTO language is reflected in files with the extension ",(0,i.kt)("inlineCode",{parentName:"p"},".dto"),". Once compilation is complete, these files have no value. So these files cannot be packaged in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/main/resources"),", but should be placed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/main/dto")," directory."),(0,i.kt)("p",null,"Therefore, the first step is to create the ",(0,i.kt)("inlineCode",{parentName:"p"},"dto")," subdirectory under ",(0,i.kt)("inlineCode",{parentName:"p"},"src/main"),"."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"dto files are compiled by Jimmer's Annotation Processor ",(0,i.kt)("em",{parentName:"p"},"(Java)")," or Kotlin ",(0,i.kt)("em",{parentName:"p"},"(Kotlin)"),". So there are two points to note:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For projects with multi-module structure, dto files need to be defined in the subproject where the entity types are located.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you are using an IDE like Intellij to develop projects"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If Java/Kotlin files other than dto files are also modified, clicking the run button in the IDE directly can cause dto files to recompile")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, if no Java/Kotlin files other than dto files are modified, simply clicking the run button in the IDE will not cause dto files to recompile unless rebuild is explicitly invoked!"))))),(0,i.kt)("p",{parentName:"admonition"},"If you have good suggestions to solve this problem, please feel free to provide feedback.")),(0,i.kt)("p",null,"Assume there is a Jimmer entity type with the fully qualified type name ",(0,i.kt)("inlineCode",{parentName:"p"},"com.yourcompany.yourproject.Book"),", which is decorated by ",(0,i.kt)("inlineCode",{parentName:"p"},"@org.babyfish.jimmer.sql.Entity")," ",(0,i.kt)("em",{parentName:"p"},"(DTO language only supports Entity types)"),", then"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create the directory ",(0,i.kt)("inlineCode",{parentName:"p"},"com/yourcompany/yourproject")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/main/dto"),", the directory consistent with the package name")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a new file ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.dto")," in the directory created in the previous step. This file must have the same name as the class and have the extension ",(0,i.kt)("inlineCode",{parentName:"p"},".dto")))),(0,i.kt)("p",null,"Users can edit the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.dto")," file to define any number of shapes with ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," type as the aggregate root. Here, let's define a DTO shape first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    ...omit...\n}\n")),(0,i.kt)("p",null,"After compilation, the Java/Kotlin type ",(0,i.kt)("inlineCode",{parentName:"p"},"BookView")," will be generated"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookView.java"',title:'"BookView.java"'},"package com.yourcompany.yourproject.dto;\n\nimport com.yourcompany.yourproject.Book;\nimport org.babyfish.jimmer.View;\n\n@lombok.Data\npublic class BookView implements View<Book> {\n    ...omit...\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookView.kt"',title:'"BookView.kt"'},"package com.yourcompany.yourproject.dto\n\nimport com.yourcompany.yourproject.Book\nimport org.babyfish.jimmer.View\n\ndata class BookView(\n    ...omit...\n) : View<Book> {\n    ...omit...\n}\n")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The generated type is in the package ",(0,i.kt)("inlineCode",{parentName:"p"},"com.yourcompany.yourproject.dto"),", which has a ",(0,i.kt)("inlineCode",{parentName:"p"},"dto")," subpackage relative to the package where the entity is located.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Java, the generated type assumes the user uses lombok.")))),(0,i.kt)("h2",{id:"3-input-input-only-modifiers"},"3. input, input-only modifiers"),(0,i.kt)("p",null,"Shapes can be decorated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," modifier, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    ...omit...\n}\n\nAnnotherBookView {\n    ...omit... \n}\n\ninput BookInput {\n    ...omit...\n}\n\ninput AnnotherBookInput {\n    ...omit...\n}\n")),(0,i.kt)("p",null,"This means:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"BookView")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AnnotherBookView")," are used as query outputs. The generated Java/Kotlin types implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.View<E>")," interface"),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"It is recommended that output shapes end with ",(0,i.kt)("inlineCode",{parentName:"p"},"View")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"BookInput")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AnnotherBookInput")," are used as save inputs. The generated Java/Kotlin types implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.Input<E>")," interface"),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"It is recommended that input shapes end with ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In fact, there is another kind of DTO object without direct Input/Output semantics, which is often used as the query specification parameter for complex dynamic query APIs.\nLike the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/example/java/jimmer-sql/src/main/dto/org/babyfish/jimmer/sql/example/model/Author.dto"},"AuthorSpecification")," type defined in the example."),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Jimmer makes no recommendation on whether this type of query specification parameter should be defined as input type, but it is recommended that this type ends with ",(0,i.kt)("inlineCode",{parentName:"p"},"Specification"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"Spec"),".")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Compared with Output DTO:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The id property in the input DTO is nullable if the id property of the entity is configured with ",(0,i.kt)("inlineCode",{parentName:"p"},"@GeneratedValue"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The input DTO can only define properties that can be saved, such as simple properties, ordinary ORM association properties and id-view properties.\nProperties that cannot be saved, such as transient properties, formula properties, calculated properties, and remote associations, cannot be defined, otherwise compilation errors will occur. ")))),(0,i.kt)("p",null,"Whether it is an output shape or an input shape, the generated Java/Kotlin type has the following capabilities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Constructor: Convert Jimmer dynamic entity object to static DTO object")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"toEntity()"),": Convert static DTO object to Jimmer dynamic entity object"))),(0,i.kt)("p",null,"Take ",(0,i.kt)("inlineCode",{parentName:"p"},"BookView")," as an example:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"Book entity = ...omit...\n\n// Entity -> DTO\nBookView dto = new BookView(entity); \n\n// DTO -> Entity  \nBook anotherEntity = dto.toEntity();\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val entity: Book = ...omit...\n\n// Entity -> DTO\nval dto = BookView(entity)  \n\n// DTO -> Entity\nval anotherEntity: Book = dto.toEntity()\n")))),(0,i.kt)("p",null,"In addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"input-only")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"inputOnly")," modifier can also be used, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"input-only BookUpdateInfo {\n    ...omit...\n} \n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"inputOnly BookUpdateInfo {\n    ...omit...\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"input-only"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"inputOnly")," works similarly to ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," and is used to decorate input types,\nbut only provides the ability to convert from DTO objects to entity objects, not the ability to convert from entity objects to DTO objects."),(0,i.kt)("p",null,"The purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"input-only"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"inputOnly")," modifier is described in ",(0,i.kt)("a",{parentName:"p",href:"#7-nullability"},"7. Nullability")),(0,i.kt)("h2",{id:"4-simple-properties"},"4. Simple Properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    id\n    name\n    editon\n}\n")),(0,i.kt)("p",null,"This means that the DTO only maps the three properties ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"editon")," of the entity, as follows:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookView.java"',title:'"BookView.java"'},"@lombok.Data\npublic class BookView implements View<Book> {\n\n    private long id;\n    private String name;\n    private String edition;\n\n    public BookView(Book book) {\n        ...omit...\n    }\n\n    @Override\n    public Book toEntity() {\n        ...omit... \n    }\n\n    ...omit other members...\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookView.kt"',title:'"BookView.kt"'},'data class BookView(\n    val id: Long = 0, \n    val name: String = "",\n    val edition: Int = 0  \n) : View<Book> {\n\n    constructor(book: Book): this(...omit...)\n\n    override fun toEntity(): Book {\n        ...omit...\n    }\n\n    ...omit other members...\n}\n')))),(0,i.kt)("h2",{id:"5-allscalars"},"5. allScalars"),(0,i.kt)("p",null,"The DTO language supports a special macro property, ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars"),", which means mapping all scalar properties in the entity."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    #allScalars\n}\n")),(0,i.kt)("p",null,"Same as the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," type definition of official example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Book")," itself has scalar properties ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"edition")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"price"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Book")," inherits ",(0,i.kt)("inlineCode",{parentName:"p"},"TenantAware")," that defines property ",(0,i.kt)("inlineCode",{parentName:"p"},"tenant"),"  ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Book")," also inherits ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonEntity")," ",(0,i.kt)("em",{parentName:"p"},"(multiple inheritance)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonEntity")," interface defines properties ",(0,i.kt)("inlineCode",{parentName:"p"},"createdTime")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"modifiedTime")))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," means automatically mapping all scalar properties of the entity, including inherited ones.  "),(0,i.kt)("p",null,"If this is not the behavior you want, then you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"allScalars(Book)")," to mean mapping only all scalar properties defined by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," type itself, not including inherited properties."),(0,i.kt)("p",null,"In fact, ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," supports multiple parameters, for example:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Macro Expression"),(0,i.kt)("th",{parentName:"tr",align:null},"Automatically Mapped Properties"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars"),(0,i.kt)("td",{parentName:"tr",align:null},"createdTime, modifiedTime, tenant, id, name, edition, price")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(Book)"),(0,i.kt)("td",{parentName:"tr",align:null},"id, name, edition, price")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(TenantAware)"),(0,i.kt)("td",{parentName:"tr",align:null},"tenant")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(CommonEntity)"),(0,i.kt)("td",{parentName:"tr",align:null},"createdTime, modifiedTime")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(Book, TenantAware)"),(0,i.kt)("td",{parentName:"tr",align:null},"tenant, id, name, edition, price")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(Book, CommonEntity)"),(0,i.kt)("td",{parentName:"tr",align:null},"createdTime, modifiedTime, id, name, edition, price")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(TenantAware, CommonEntity)"),(0,i.kt)("td",{parentName:"tr",align:null},"createdTime, modifiedTime, tenant")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"#allScalars(Book, TenantAware, CommonEntity)"),(0,i.kt)("td",{parentName:"tr",align:null},"createdTime, modifiedTime, tenant, id, name, edition, price")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If using the ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," macro, it must be defined as the first property, otherwise a compilation error will occur.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If parameters are specified for the ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," macro, each parameter must be the current entity or its base type, otherwise a compilation error will occur. ")))),(0,i.kt)("h2",{id:"6-negative-properties"},"6. Negative Properties"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," macro and inheritance discussed later will batch map multiple properties. Negative properties can remove some properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    #allScalars\n    // highlight-next-line  \n    -tenant \n}\n")),(0,i.kt)("p",null,"Same as before, if we understand according to the inheritance relationship of ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," type in the official example:  "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," will add properties ",(0,i.kt)("inlineCode",{parentName:"p"},"createdTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"modifiedTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"tenant"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"edition")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"price"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"-tenant")," removes the ",(0,i.kt)("inlineCode",{parentName:"p"},"tenant")," property from it, finally adding properties ",(0,i.kt)("inlineCode",{parentName:"p"},"createdTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"modifiedTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"edition")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"price"),"."))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The negative property specifies the actual name of the DTO property, not the entity property name. Here the two are the same, so there is no difference."),(0,i.kt)("p",{parentName:"admonition"},"The difference between the two will be revealed in the later section ",(0,i.kt)("a",{parentName:"p",href:"#8-renaming"},"Renaming"),".")),(0,i.kt)("p",null,"It is not difficult to see that for this example, there is another syntax equivalent to it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    // Exclude `TenantAware`\n    #allScalars(Book, CommonEntity)\n} \n")),(0,i.kt)("h2",{id:"7-nullability"},"7. Nullability"),(0,i.kt)("p",null,"By default, the nullability of DTO properties is the same as that of the original properties. But we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," to modify the nullability of DTO properties."),(0,i.kt)("h3",{id:"71-"},"7.1 ",(0,i.kt)("inlineCode",{parentName:"h3"},"?")),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," to make the DTO property nullable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"input UpdateBookInput {  \n    #allScalars\n    // highlight-next-line\n    price?\n}\n")),(0,i.kt)("p",null,"In the entity ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price")," cannot be null, while the corresponding DTO property ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateBookInput.price")," can be null. This seems contradictory, but Jimmer can handle such contradictions ",(0,i.kt)("em",{parentName:"p"},"(without discussing whether it is appropriate to use this feature in specific scenarios)"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When converting an entity to a DTO, if ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price")," is not loaded ",(0,i.kt)("em",{parentName:"p"},"(although the property cannot be null, dynamic objects can have unloaded properties)"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateBookInput.price")," in the converted DTO is null.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When converting a DTO to an entity, if ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateBookInput.price")," is null, then ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.price")," in the converted entity is in an unloaded state, that is, this property of the dynamic object is not assigned at all."))),(0,i.kt)("p",null,"You can even use ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"allScalars")," to make all automatically mapped non-associated properties nullable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"input UpdateBookInput {\n    // highlight-next-line \n    #allScalars? \n}\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"However, this feature needs to be used with caution. The meaning of static types should be fixed and clear, not as flexible and changeable as dynamic types."),(0,i.kt)("p",{parentName:"admonition"},"For entity properties that can be null in the first place, there are three states: non-null, null and unloaded ",(0,i.kt)("em",{parentName:"p"},"(unknown)"),"; while static DTO properties only have two states: non-null and null. That is, introducing static DTO types itself has already led to loss of information."),(0,i.kt)("p",{parentName:"admonition"},"Therefore, for entity properties that can be null in the first place, no matter how the corresponding DTO property is set, after DTO conversion, the nullable property of the dynamic entity object must be assigned ",(0,i.kt)("em",{parentName:"p"},"(may be null)"),", but the unloaded state cannot appear. If passed to ",(0,i.kt)("a",{parentName:"p",href:"../../mutation/save-command"},"save command"),", null will definitely cause the corresponding field in the table to be updated, rather than not updated like non-null properties that have not been assigned."),(0,i.kt)("p",{parentName:"admonition"},"For query specification parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"Specification")," without with direct Input/Output semantics,\nsuch as ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/example/java/jimmer-sql/src/main/dto/org/babyfish/jimmer/sql/example/model/Author.dto"},"AuthorSpecification"),",\nthis feature is very suitable, because each query parameter of dynamic query should be optional,\nunless users have to be required to provide some query conditions due to performance issues."),(0,i.kt)("p",{parentName:"admonition"},"However, for other DTO types with ",(0,i.kt)("inlineCode",{parentName:"p"},"Input"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"Output")," semantics, this feature is not recommended. ")),(0,i.kt)("h3",{id:"72-"},"7.2 ",(0,i.kt)("inlineCode",{parentName:"h3"},"!")),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," to modify the DTO property to be non-null. But its usage is limited and can only be used in the following two cases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Modify the id property in ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"input-only")," types"),(0,i.kt)("p",{parentName:"li"},"As mentioned earlier, if the id property is configured with ",(0,i.kt)("inlineCode",{parentName:"p"},"@GeneratedValue"),", the corresponding input DTO type will set the id property to nullable."),(0,i.kt)("p",{parentName:"li"},"However, this behavior does not always match the user's expectations. ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," can be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"input-only")," types to modify the id property to make it non-null, for example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"input BookUpdateInfo {\n    #allScalars \n    #highlight-next-line\n    id!\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"input-only")," type, convert a nullable entity property to non-null, for example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"input-only BookUpdateInfo {\n    #allScalars\n    #highlight-next-line\n    store! {\n        ...omit...\n    }\n}\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The property in the entity can be null, but the corresponding property in the DTO is non-null, so it is impossible to support converting entity objects to DTO objects, only converting DTO objects to entity objects."),(0,i.kt)("p",{parentName:"admonition"},"This is also the meaning of the ",(0,i.kt)("inlineCode",{parentName:"p"},"input-only")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"inputOnly")," keywords.")))),(0,i.kt)("h2",{id:"8-renaming"},"8. Renaming"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword can be used to set an alias for the property, so that the entity property name and DTO property name can be different."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"as")," has two usage, it can set alias for one property precisely, it can also set aliases for multiple properties vaguely."),(0,i.kt)("h3",{id:"81-rename-single-property"},"8.1. Rename Single Property"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n    name as bookName \n}\n")),(0,i.kt)("h3",{id:"82-rename-multiple-properties"},"8.2. Rename Multiple Properties"),(0,i.kt)("p",null,"Assume there is an entity type called ",(0,i.kt)("inlineCode",{parentName:"p"},"Robot")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Robot.dto"',title:'"Robot.dto"'},"OrderView {\n    as (^ -> oldSystem) { \u2776\n        prop1\n        prop2 \n    }\n    as ($ -> ForNewSystem) { \u2777\n        prop3\n        prop4\n    }\n}\n")),(0,i.kt)("p",null,"Where: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 Add prefix ",(0,i.kt)("inlineCode",{parentName:"p"},"oldSystem")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"prop1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"prop2"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," indicates the start position")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 Add suffix ",(0,i.kt)("inlineCode",{parentName:"p"},"ForNewSystem")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"prop3")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"prop4"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," indicates the end position"))),(0,i.kt)("p",null,"The generated ",(0,i.kt)("inlineCode",{parentName:"p"},"RobotView")," class is:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookView.java"',title:'"BookView.java"'},"@lombok.Data  \npublic class RobotView implements View<Robot> {\n\n    private String oldSystemProp1;\n    private String oldSystemProp2;\n\n    private String prop3ForNewSystem; \n    private String prop4ForNewSystem;\n\n    ...omit other members...\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookView.kt"',title:'"BookView.kt"'},'data class RobotView(\n    \n    val oldSystemProp1 = "",\n    val oldSystemProp2 = "",\n\n    val prop3ForNewSystem = "",\n    val prop4ForNewSystem = ""  \n) : View<Robot> {\n\n    ...omit other members...\n}\n')))),(0,i.kt)("p",null,"Most properties can be defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"as() {...}")," block, including ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars"),", for example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Robot.dto"',title:'"Robot.dto"'},"RobotView {\n    # highlight-next-line\n    as(^ -> robot) {\n        # highlight-next-line  \n        #allScalars\n    }\n}\n")),(0,i.kt)("p",null,"The following list all usages of ",(0,i.kt)("inlineCode",{parentName:"p"},"as() {...}")," block:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Code Demo"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as(^ -> prefix)"),(0,i.kt)("td",{parentName:"tr",align:null},"Add prefix")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as(^prefix ->)"),(0,i.kt)("td",{parentName:"tr",align:null},"Remove prefix")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as(^prefix -> newPrefix)"),(0,i.kt)("td",{parentName:"tr",align:null},"Replace prefix")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as($ -> suffix)"),(0,i.kt)("td",{parentName:"tr",align:null},"Add suffix")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as($suffix ->)"),(0,i.kt)("td",{parentName:"tr",align:null},"Remove suffix")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as($suffix -> newSuffix)"),(0,i.kt)("td",{parentName:"tr",align:null},"Replace suffix")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as(infix -> )"),(0,i.kt)("td",{parentName:"tr",align:null},"Remove any position content")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"as(infix -> newInfix)"),(0,i.kt)("td",{parentName:"tr",align:null},"Replace any position content")))),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"^")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," cannot appear at the same time, because it means renaming a single property precisely, which duplicates existing functionality")),(0,i.kt)("h2",{id:"9-enum-mapping"},"9. Enum Mapping"),(0,i.kt)("p",null,"By default, enum type properties of entities are mapped to DTO properties as enums. "),(0,i.kt)("p",null,"You can map enums to numbers or strings."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Map to numbers"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"AuthorView {\n    #allScalars\n    gender {\n        MALE -> 100\n        FEMALE -> 101 \n    }\n}\n")),(0,i.kt)("p",{parentName:"li"},"This generates the following code:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// BookView.java\n@lombok.Data\npublic class AuthorView implements View<AuthorView> {\n\n    private int gender;\n\n    ...other members omitted...\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// BookView.kt \ndata class RobotView(\n    val gender: Int,\n    ...other members omitted...\n) : View<Robot> {\n    ...other members omitted...  \n}\n"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Map to strings"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'AuthorView {\n    #allScalars\n    gender {\n        MALE -> "Male"\n        FEMALE -> "Female"\n    }\n}\n')),(0,i.kt)("p",{parentName:"li"},"This generates the following code:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// BookView.java\n@lombok.Data\npublic class AuthorView implements View<AuthorView> {\n\n    private String gender;\n\n    ...other members omitted...  \n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// BookView.kt\ndata class RobotView(\n    val gender: String,\n    ...other members omitted...   \n) : View<Robot> {\n    ...other members omitted...\n}\n")))))),(0,i.kt)("h2",{id:"10-association-properties"},"10. Association Properties"),(0,i.kt)("p",null,"Handling association properties is a very powerful feature of the DTO language. There are three usages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use directly"),(0,i.kt)("li",{parentName:"ul"},"Recursive association"),(0,i.kt)("li",{parentName:"ul"},"Use after calling ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," function"),(0,i.kt)("li",{parentName:"ul"},"Use after calling ",(0,i.kt)("inlineCode",{parentName:"li"},"flat")," function")),(0,i.kt)("h3",{id:"101-common-association"},"10.1. Common Association"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Basic usage"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Robot.dto"',title:'"Robot.dto"'},"input CompositeBookInput {\n    \n    #allScalars(Book)\n\n    # highlight-next-line\n    store {\n        #allScalars(BookStore)\n        -id \n    }\n\n    # highlight-next-line\n    authors {\n        #allScalars(Author)\n        -id\n    }\n}\n")),(0,i.kt)("p",{parentName:"li"},"The generated code is:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="CompositeBookInput.java"',title:'"CompositeBookInput.java"'},"@lombok.Data\npublic class CompositeBookInput implements Input<Book> {\n\n    @Nullable\n    private Long id;\n\n    private String name;\n\n    private int edition;\n\n    private BigDecimal price;\n\n    // highlight-next-line\n    private TargetOf_store store;\n\n    // highlight-next-line \n    private List<TargetOf_authors> authors;\n\n    @lombok.Data\n    // highlight-next-line\n    public static class TargetOf_store implements Input<BookStore> {\n    \n        private String name;\n\n        @Nullable\n        private String website;\n\n        ...omit other members...\n    }\n\n    @lombok.Data\n    // highlight-next-line\n    public static class TargetOf_authors implements Input<Author> {\n        \n        private String firstName;\n\n        private String lastName;\n\n        private Gender gender;\n\n        ...omit other members...\n    }\n\n    ...omit other members...\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="CompositeBookInput.kt"',title:'"CompositeBookInput.kt"'},'data class CompositeBookInput(\n    val id: Long? = null,\n    val name: String = "",\n    val edition: Int = 0,\n    val price: BigDecimal,\n\n    // highlight-next-line\n    val store: TargetOf_store? = null,\n    // highlight-next-line\n    val authors: List<TargetOf_authors> = emptyList(),\n) : Input<Book> {\n\n    // highlight-next-line\n    data class TargetOf_store(\n        val name: String = "",\n        val website: String? = null,\n    ) : Input<BookStore> {\n        ...omit other members...\n    }\n\n    // highlight-next-line\n    data class TargetOf_authors(\n        public val firstName: String = "",\n        public val lastName: String = "",\n        public val gender: Gender,\n    ) : Input<Author> {\n        ...omit other members...\n    }\n\n    ...omit other members...\n}\n'))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Renaming"),(0,i.kt)("p",{parentName:"li"},"If you want to rename association properties, the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," clause should be before association definition block, for example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"input CompositeBookInput {\n    \n    authors as authorList {\n        ...omit...\n    }\n\n    ...omit...\n}\n")))),(0,i.kt)("h3",{id:"102-recursive-association"},"10.2 Recursive Association"),(0,i.kt)("p",null,"For recursively associated properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeNode.parent")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeNode.childNodes")," in the attached example, the asterisk ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," can be used to mark the corresponding associated property of the DTO as a recursive property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="TreeNode.dto"',title:'"TreeNode.dto"'},"TreeNodeView {\n    \n    #allScalars\n\n    childNodes {\n        #allScalars\n    #highlight-next-line\n    }*\n}\n")),(0,i.kt)("h3",{id:"103-id-function"},"10.3. id Function"),(0,i.kt)("p",null,"For ",(0,i.kt)(s.b,{buttonText:"short associations",mdxType:"ViewMore"},(0,i.kt)(o.k,{mdxType:"ShortAssociation"})),", of course we can choose to define ",(0,i.kt)("a",{parentName:"p",href:"../../mapping/advanced/view/id-view"},"@IdView")," properties in entities, for example:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Book.java"',title:'"Book.java"'},'@Entity\npublic interface Book {\n\n    @Nullable\n    @ManyToOne  \n    BookStore store();\n\n    @ManyToMany\n    val authors: List<Author>\n\n    // highlight-next-line\n    @IdView\n    Long storeId();\n\n    // highlight-next-line \n    @IdView("authors")\n    List<Long> authorIds();\n}\n'))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Book.kt"',title:'"Book.kt"'},'@Entity\ninterface Book {\n\n    @ManyToOne\n    val store: BookStore?\n\n    @ManyToMany\n    val authors: List<Author>\n    \n    // highlight-next-line\n    @IdView\n    val storeId: Long?\n\n    // highlight-next-line\n    @IdView("authors")\n    val authorIds: List<Long>\n}\n')))),(0,i.kt)("p",null,"In cases where ",(0,i.kt)("a",{parentName:"p",href:"../../mapping/advanced/view/id-view"},"@IdView")," properties have been defined in entities, just simple reference them in DTO language:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n\n    // highlight-next-line\n    storeId\n\n    // highlight-next-line \n    authorIds\n\n    ...omit...\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"However, we cannot always rely on entity types to always declare ",(0,i.kt)("a",{parentName:"p",href:"../../mapping/advanced/view/id-view"},"@IdView")," properties. A better approach should not have this assumption."),(0,i.kt)("p",{parentName:"admonition"},"Therefore, the DTO language supports calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," function on associated properties to achieve the same purpose. ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Book.dto"',title:'"Book.dto"'},"BookView {\n\n    // highlight-next-line\n    id(store)\n\n    // highlight-next-line\n    id(authors) as authorIds\n\n    ...omit...\n}\n")),(0,i.kt)("p",null,"The functionality of this code is exactly the same as the previous example, but no longer assumes that entity types always declare ",(0,i.kt)("a",{parentName:"p",href:"../../mapping/advanced/view/id-view"},"@IdView")," properties, which is a better approach."),(0,i.kt)("h3",{id:"104-flat-function"},"10.4. flat Function"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," function can only be used for associations ",(0,i.kt)("em",{parentName:"p"},"(one-to-one or many-to-one)"),", not collection associations ",(0,i.kt)("em",{parentName:"p"},"(one-to-many or many-to-many)"),". It is used to lift the properties of the associated DTO to the current DTO type to obtain a flat object without associations."),(0,i.kt)("p",null,"Take the ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeNode")," entity in the official example as an example ",(0,i.kt)("em",{parentName:"p"},"(in fact, this example is wrong, we will discuss this issue later)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="TreeNode.dto"',title:'"TreeNode.dto"'},"FlatTreeNodeView {\n    \n    #allScalars(TreeNode)\n\n    # highlight-next-line\n    flat(parent) {\n        #allScalars(TreeNode)\n    }\n}\n")),(0,i.kt)("p",null,"As mentioned earlier, this example is wrong, because the aggregate root and associated object both have the properties ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),". Unconditionally extracting the properties of the associated object to the aggregate root must inevitably lead to name conflicts, eventually causing the DTO language to report compilation errors."),(0,i.kt)("p",null,"The correct approach is to combine it with the ",(0,i.kt)("inlineCode",{parentName:"p"},"as(...) {}")," block that renames multiple user properties vaguely. Let's look at a new example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="TreeNode.dto"',title:'"TreeNode.dto"'},"FlatTreeNodeView {\n    \n    #allScalars(TreeNode) // id, name\n\n    # highlight-next-line\n    flat(parent) {\n        # highlight-next-line\n        as(^ -> parent) {\n            // parentId, parentName\n            #allScalars(TreeNode)\n        }\n    }\n} \n")),(0,i.kt)("p",null,"This way, we get a flat DTO type with 4 properties: ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"parentId")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"parentName"),". "),(0,i.kt)("p",null,"You can even nest the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," function to flatten multi-level associations into flat objects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="TreeNode.dto"',title:'"TreeNode.dto"'},"FlatTreeNodeView {\n    \n    #allScalars(TreeNode)\n\n    # highlight-next-line\n    flat(parent) {\n        as(^ -> parent) {\n            #allScalars(TreeNode) \n        }\n        # highlight-next-line\n        flat(grandParent) {\n            as(^ -> parent) {\n                #allScalars(TreeNode)\n            }\n            \n        }   \n    }\n}\n")),(0,i.kt)("p",null,"This way, we get a flat DTO type with 6 properties: ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"parentId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"parentName"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"grandParentId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"grandParentName"),"."),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'TreeNode treeNode = treeNodeDraft.$.produce(cola -> {\n    cola.setId(4L);\n    cola.setName("Coca cola");\n    cola.applyParent(drinks -> {\n        drinks.setId(3L);\n        drinks.setName("Drinks");\n        drinks.applyParent(food -> {\n            food.setId(2L);\n            food.setName("Food");\n        })\n    })\n});\n\n// Convert hierarchical Entity to flat DTO\nFlatTreeNodeView view = new FlatTreeNodeView(treeNode); \n\nSystem.out.println(view);\n'))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val treeNode = new(TreeNode::class).by {\n    id = 4L\n    name = "Coca cola" \n    parent().apply {\n        id = 3L\n        name = "Drinks"\n        parent().apply {\n            id = 2L\n            name = "Food"\n        }   \n    }\n}\n\n// Convert hierarchical Entity to flat DTO\nval view = FlatTreeNodeView(treeNode)\n\nprintln(view) \n')))),(0,i.kt)("p",null,"The output is ",(0,i.kt)("em",{parentName:"p"},"(formatted for readability)"),":  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'com.yourcompany.yourproject.FlatTreeNodeView(\n    id = 4,\n    name = Coco cola, \n    parentId = 3,\n    parentName = Drinks,\n    grandParentId = 2,\n    grandParentName = "Food"\n)\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," approach also has drawbacks. For ",(0,i.kt)("strong",{parentName:"p"},"output")," DTOs, the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," approach is controversial and is not recommended for blind adoption."),(0,i.kt)("p",null,"Please refer to ",(0,i.kt)(s.b,{buttonText:"Controversy over whether output DTOs should use flat mode",mdxType:"ViewMore"},(0,i.kt)(m,{mdxType:"FlatProblem"}))),(0,i.kt)("h2",{id:"11-inheritance"},"11. Inheritance"),(0,i.kt)("p",null,"Inheritance between DTO type definitions is supported, with the following features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Inheritance between DTO type definitions is inheritance at the configuration level only. So it is irrelevant to the inheritance relationship of the original entities, nor to the generated DTO types ",(0,i.kt)("em",{parentName:"p"},"(as of the current version, Java/Kotlin classes with inheritance relationships will not be generated)"),". ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Inheritance between DTO types is only within the dto file.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Inheritance between DTO types is multiple inheritance, that is, a DTO type definition can inherit from multiple DTO types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"input type definitions can only inherit from input type definitions."))),(0,i.kt)("p",null,"For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Robot.dto"',title:'"Robot.dto"'},"\nBaseRobotView1 {\n    ...omit...\n}\n\nBaseRobotView2 {\n    ...omit... \n}\n\n# highlight-next-line\nDefaultRobotView : BaseRobotView1, BaseRobotView2 {\n    ...omit...\n}\n")),(0,i.kt)("p",null,"For the generated Java/Kotlin type ",(0,i.kt)("inlineCode",{parentName:"p"},"DefaultRobotView")," class, there is no Java/Kotlin inheritance relationship at all, because:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Classes are generated rather than interfaces, multiple inheritance cannot be achieved")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Due to the existence of negative property features, derived DTO type definitions may have fewer properties than base DTO type definitions"))),(0,i.kt)("p",null,'This is the fundamental reason why "Inheritance between DTO type definitions is inheritance only at the configuration level".'),(0,i.kt)("p",null,"However, the above code will lead to the generation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseRobotView1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseRobotView2")," classes in Java/Kotlin.  "),(0,i.kt)("p",null,"If you expect the base DTO type definition to be used only for the derived DTO type definition, without generating any Java/Kotlin types itself, you can add the ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract")," modifier, as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Robot.dto"',title:'"Robot.dto"'},"\n# highlight-next-line \nabstract BaseRobotView1 {\n    ...omit...\n}\n\n# highlight-next-line\nabstract BaseRobotView2 {\n    ...omit...\n}\n\nDefaultRobotView : BaseRobotView1, BaseRobotView2 {\n    ...omit... \n} \n")),(0,i.kt)("h2",{id:"12-custom-properties"},"12. Custom Properties"),(0,i.kt)("h3",{id:"121-getting-started-with-custom-properties"},"12.1 Getting Started with Custom Properties"),(0,i.kt)("p",null,"In the examples we have discussed so far, all DTO properties are mapped from entity properties and become mapping properties."),(0,i.kt)("p",null,"In addition to mapping properties, DTO types also support custom properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Author.dto"',title:'"Author.dto"'},"import java.util.LocaleDateTime \u2776\n\nAuthorSpecification {\n    \n    #allScalars(Author)? - id\n\n    minCreatedTime: LocaleDateTime?  \u2777\n    maxCreatedTimeExclusive: LocaleDateTime?  \u2778\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 Import types to simplify subsequent custom property definitions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 \u2778 Define custom property definitions"),(0,i.kt)("p",{parentName:"li"},"  Custom properties use syntax similar to Kotlin, ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," can be used to explicitly make the property nullable, otherwise it cannot be null."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Kotlin projects, types that match exactly are generated")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Java projects, in addition to the top level type ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," being used to generate ",(0,i.kt)("inlineCode",{parentName:"p"},"@org.jetbrains.annotations.Nullable")," annotations on the target Java field, the ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," in the internal generics will be ignored"),(0,i.kt)("admonition",{parentName:"li",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The custom properties here allow null. To define non-null properties ",(0,i.kt)("em",{parentName:"p"},"(i.e. remove ",(0,i.kt)("inlineCode",{parentName:"em"},"?"),")"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"input-only"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"inputOnly")," modifier must be used")))))),(0,i.kt)("p",null,"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"AuthorSpecification")," does not have direct Input/Output semantics, it is used as a query specification parameter for complex dynamic queries, for example:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="AuthorRepository.java"',title:'"AuthorRepository.java"'},"public interface AuthorRepository extends JRepository<Author, Long> {\n    \n    AuthorTable table = AuthorTable.$;\n\n    default List<Author> find(AuthorSpecification spec) {\n        return sql()\n            .createQuery(table)\n            .whereIf(\n                StringUtils.hasContent(spec.getFirstName()),\n                table.firstName().ilike(spec.getFirstName() != null)\n            )\n            .whereIf(\n                StringUtils.hasContent(spec.getLastName()),\n                table.lastName().ilike(spec.getLastName() != null)\n            )\n            .whereIf(\n                spec.getGender() != null,\n                table.gender().eq(sepc.getGender());\n            )\n            .whereIf(\n                spec.getMinCreatedTime() != null,\n                () -> table.createdTime().ge(spec.getMinCreatedTime())\n            )\n            .whereIf(\n                spec.getMaxCreatedTimeExclusive() != null,\n                () -> table.createdTime().lt(spec.getMaxCreatedTimeExclusive())\n            )\n            .select(table)\n            .execute()\n    }\n}\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="AuthorRepository.kt"',title:'"AuthorRepository.kt"'},"interface AuthorRepository : KRepository<Author, Long> {\n\n    fun find(spec: AuthorSpecification): List<Author> =\n        sql\n            .createQuery(Author::class) {\n                spec.firstName?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.firstName ilike it)\n                }\n                spec.lastName?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.lastName ilike it)\n                }\n                spec.gender?.let {\n                    where(table.gender eq it)\n                }\n                spec.minCreatedTime?.let {\n                    where(table.createdTime ge it)\n                }\n                spec.maxCreatedTimeExclusive?.let {\n                    where(table.createdTime lt it)\n                }\n                select(table)\n            }\n            .execute()\n}\n")))),(0,i.kt)("p",null,"For other non-associated properties, the query condition is a single value query condition like ",(0,i.kt)("inlineCode",{parentName:"p"},"eq")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ilike"),", so simply using ",(0,i.kt)("inlineCode",{parentName:"p"},"#allScalars")," mapping is sufficient."),(0,i.kt)("p",null,"However, the query conditions corresponding to ",(0,i.kt)("inlineCode",{parentName:"p"},"createdTime")," are relatively complex, which is a range query, and cannot simply map the ",(0,i.kt)("inlineCode",{parentName:"p"},"createdTime")," property in the mapped entity, but needs two boundary properties: ",(0,i.kt)("inlineCode",{parentName:"p"},"minCreatedTime")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"maxCreatedTimeExclusive"),"."),(0,i.kt)("p",null,"It can be seen that for query specification parameters like ",(0,i.kt)("inlineCode",{parentName:"p"},"AuthorSpecification"),", custom properties can bring great convenience, mapping properties that can be mapped, and customizing properties that cannot be mapped."),(0,i.kt)("p",null,"Therefore, the following is recommended:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Specificiation DTO: Encouraged to use, custom properties are designed for this type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Input DTO: A small number can be used, allowing a small amount of control information to be mixed in the Input DTO."),(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"toEntity")," method of the DTO object will ignore this information and convert other information into a clean dynamic entity object for ",(0,i.kt)("a",{parentName:"p",href:"../../mutation/save-command"},"save command")," to use")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Output DTO: Not recommended"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"First, Output DTOs themselves are not required. Letting query methods return dynamic objects directly, supplemented by ",(0,i.kt)("a",{parentName:"p",href:"../../spring/client/api#declare-fetchby"},"@FetchBy annotations"),", is already a very powerful solution.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Second, even if Output DTOs are used, Output DTO objects will only have the properties of entity objects, unless you are willing to manually populate custom properties."))),(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For output types, custom properties are entity-level things ",(0,i.kt)("em",{parentName:"p"},"(so Output DTOs are not required)"),"."),(0,i.kt)("p",{parentName:"admonition"},"Please refer to ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"../../mapping/advanced/view"},"View Properties"),"\u3001",(0,i.kt)("a",{parentName:"em",href:"../../mapping/advanced/calculated/formula"},"Simple Calculated Properties"),"\u3001or ",(0,i.kt)("a",{parentName:"em",href:"../../mapping/advanced/calculated/transient"},"Complex Calculated Properties")))))),(0,i.kt)("h3",{id:"122-built-in-types"},"12.2 Built-in Types"),(0,i.kt)("p",null,"So-called built-in types are types built into the DTO language that do not require import through ",(0,i.kt)("inlineCode",{parentName:"p"},"import"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Primitive and boxed types"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"DTO Language Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Java Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Kotlin Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Boolean")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Boolean?"),(0,i.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Boolean?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Char"),(0,i.kt)("td",{parentName:"tr",align:null},"char"),(0,i.kt)("td",{parentName:"tr",align:null},"Char")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Char?"),(0,i.kt)("td",{parentName:"tr",align:null},"Character"),(0,i.kt)("td",{parentName:"tr",align:null},"Char?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Byte"),(0,i.kt)("td",{parentName:"tr",align:null},"byte"),(0,i.kt)("td",{parentName:"tr",align:null},"Byte")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Byte?"),(0,i.kt)("td",{parentName:"tr",align:null},"Byte"),(0,i.kt)("td",{parentName:"tr",align:null},"Byte?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Short"),(0,i.kt)("td",{parentName:"tr",align:null},"short"),(0,i.kt)("td",{parentName:"tr",align:null},"Short")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Short?"),(0,i.kt)("td",{parentName:"tr",align:null},"Short"),(0,i.kt)("td",{parentName:"tr",align:null},"Short?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Int"),(0,i.kt)("td",{parentName:"tr",align:null},"int"),(0,i.kt)("td",{parentName:"tr",align:null},"Int")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Int?"),(0,i.kt)("td",{parentName:"tr",align:null},"Integer"),(0,i.kt)("td",{parentName:"tr",align:null},"Int?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Long"),(0,i.kt)("td",{parentName:"tr",align:null},"long"),(0,i.kt)("td",{parentName:"tr",align:null},"Long")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Long?"),(0,i.kt)("td",{parentName:"tr",align:null},"Long"),(0,i.kt)("td",{parentName:"tr",align:null},"Long?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Float"),(0,i.kt)("td",{parentName:"tr",align:null},"float"),(0,i.kt)("td",{parentName:"tr",align:null},"Float")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Float?"),(0,i.kt)("td",{parentName:"tr",align:null},"Float"),(0,i.kt)("td",{parentName:"tr",align:null},"Float?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Double"),(0,i.kt)("td",{parentName:"tr",align:null},"double"),(0,i.kt)("td",{parentName:"tr",align:null},"Double")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Double?"),(0,i.kt)("td",{parentName:"tr",align:null},"Double"),(0,i.kt)("td",{parentName:"tr",align:null},"Double?"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Any and String types"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"DTO Language Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Java Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Kotlin Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Any"),(0,i.kt)("td",{parentName:"tr",align:null},"Object"),(0,i.kt)("td",{parentName:"tr",align:null},"Any")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"String"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Array types"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"DTO Language Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Java Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Kotlin Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Boolean",">"),(0,i.kt)("td",{parentName:"tr",align:null},"boolean[]"),(0,i.kt)("td",{parentName:"tr",align:null},"BooleanArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Boolean?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Boolean[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Boolean?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Char",">"),(0,i.kt)("td",{parentName:"tr",align:null},"char[]"),(0,i.kt)("td",{parentName:"tr",align:null},"CharArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Char?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Character[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Char?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Byte",">"),(0,i.kt)("td",{parentName:"tr",align:null},"byte[]"),(0,i.kt)("td",{parentName:"tr",align:null},"ByteArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Byte?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Byte[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Byte?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Short",">"),(0,i.kt)("td",{parentName:"tr",align:null},"short[]"),(0,i.kt)("td",{parentName:"tr",align:null},"ShortArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Short?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Short[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Short?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Int",">"),(0,i.kt)("td",{parentName:"tr",align:null},"int[]"),(0,i.kt)("td",{parentName:"tr",align:null},"IntArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Int?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Integer[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Int?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Long",">"),(0,i.kt)("td",{parentName:"tr",align:null},"long[]"),(0,i.kt)("td",{parentName:"tr",align:null},"LongArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Long?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Long[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Long?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Float",">"),(0,i.kt)("td",{parentName:"tr",align:null},"float[]"),(0,i.kt)("td",{parentName:"tr",align:null},"FloatArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Float?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Float[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Float?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Double",">"),(0,i.kt)("td",{parentName:"tr",align:null},"double[]"),(0,i.kt)("td",{parentName:"tr",align:null},"DoubleArray")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Double?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Double[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","Double?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","UserType",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","UserType",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","UserType?",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","UserType?",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","*",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Object[]"),(0,i.kt)("td",{parentName:"tr",align:null},"Array","<","*",">"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Collection types"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"DTO Language Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Java Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Kotlin Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Iterable","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Iterable","<","? extends E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Iterable","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MutableIterable","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Iterable","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"MutableIterable","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Collection","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Collection","<","? extends E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Collection","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MutableCollection","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Collection","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"MutableCollection","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"List","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","? extends E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MutableList","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"MutableList","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Set","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Set","<","? extends E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Set","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MutableSet","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Set","<","E",">"),(0,i.kt)("td",{parentName:"tr",align:null},"MutableSet","<","E",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Map","<","K, V",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Map","<","? extends K, ? extends V",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Map","<","K, V",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"MutableMap","<","K, V",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Map","<","K, V",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Mutable","<","K, V",">")))))),(0,i.kt)("h3",{id:"123-generic-parameter-modifiers"},"12.3 Generic Parameter Modifiers"),(0,i.kt)("p",null,"In addition to generics in built-in array and collection types, generics of other generic classes also support using ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"out")," to modify generic parameters, for example:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"DTO Language Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Java Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Generated Kotlin Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","UserType2",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","UserType2",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","UserType2",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","out UserType2",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","? extends UserType2",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","out UserType2",">")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","in UserType2",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","? super UserType2",">"),(0,i.kt)("td",{parentName:"tr",align:null},"UserType1","<","in UserType2",">")))),(0,i.kt)("h3",{id:"124-import-statements"},"12.4 Import Statements"),(0,i.kt)("p",null,"In addition to built-in types, other types must be written in qualified name, or imported at the beginning of the file using import statements,\notherwise they will be considered to be in the same package as the current entity."),(0,i.kt)("p",null,"The DTO language supports multiple styles of import statements, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Single class import"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"import java.time.LocalDateTime\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Single class renamed import"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"import java.time.LocalDateTime as LDT\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Multiple class import"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"import java.time.{\n    LocalDateTime,\n    OffsetDataTime,\n    ZonedDataTime\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Multiple class renamed import"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"import java.time.{\n    LocalDateTime as LDT,\n    OffsetDataTime as ODT,\n    ZonedDataTime as ZDT\n}\n")))),(0,i.kt)("h2",{id:"13-annotations"},"13. Annotations"),(0,i.kt)("h3",{id:"131-basic-usage"},"13.1 Basic Usage"),(0,i.kt)("p",null,"You can use annotations to decorate DTO types, mapping properties and custom properties in DTO language:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="Author.dto"',title:'"Author.dto"'},'import org.babyfish.jimmer.client.Doc\nimport org.springframework.format.annotation.DateTimeFormat\n\n@Doc("Query specification for complex queries of Author objects") \u2776\nAuthorSpecification {\n    \n    #allScalars\n\n    @Doc("Fuzzy match")  \u2777  \n    firstName\n\n    @Doc("Fuzzy match")  \u2778\n    lastName\n\n    @Doc("Minimum create time, inclusive") \u2779\n    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") \u277a\n    minCreatedTime: LocalDateTime?\n\n    @Doc("Maximum create time, exclusive") \u277b\n    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") \u277c\n    maxCreatedTimeExclusive: LocalDateTime?\n}\n')),(0,i.kt)("p",null,"Where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 Decorate type  ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 \u2778 Decorate mapping properties")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2779 \u277a \u277b \u277c Decorate custom properties"))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"There is a detail to note"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-sh",metastring:'title="BookView"',title:'"BookView"'},"...omit import...\n\nBookView {\n\n    ...omit other properties...\n\n    # highlight-next-line\n    @A authors @B {\n        ...omit association object properties... \n    }\n\n    ...omit other DTO types...\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Where:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"@A")," decorates the ",(0,i.kt)("inlineCode",{parentName:"p"},"authors")," property  ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"@B")," decorates the anonymous association type")))),(0,i.kt)("h3",{id:"132-annotation-override"},"13.2 Annotation Override"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"As mentioned earlier, DTO language supports annotations to directly control the annotations of the generated DTO types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If a DTO property is not decorated by any annotation, the annotations on the corresponding property of the original entity will be copied ",(0,i.kt)("em",{parentName:"p"},"(if the DTO property is mapped, not custom)"),".\nWhere any ",(0,i.kt)("strong",{parentName:"p"},"non"),"-jimmer annotations other than those in the ",(0,i.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.client")," package will be copied to the generated DTO type"))),(0,i.kt)("h3",{id:"133-value-parameter"},"13.3 value Parameter"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," parameter in annotations can be abbreviated, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'@UserAnnotation(value = "a", value2 = "b", value3 = "c")\n')),(0,i.kt)("p",null,"Can be abbreviated to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'@UserAnnotation("a", value2 = "b", value3 = "c")\n')),(0,i.kt)("p",null,"Unlike Java, no matter how many parameters the annotation has, the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," parameter can be abbreviated, as long as the abbreviated property is configured first."),(0,i.kt)("h3",{id:"124-mix-java-and-kotlin-syntax"},"12.4 Mix Java and Kotlin Syntax"),(0,i.kt)("p",null,"There are some minor differences between Java and Kotlin annotation syntax. DTO language mixes the features of both, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'@UserAnnotation(\n    "key1", \n    items = {\n        @Item("subKey1", description = "Detail information for subKey1 ..."),\n        @Item("subKey2", description = "Detail information for subKey2 ..."),\n        @Item("subKey3", description = "Detail information for subKey3 ...")\n    }\n)\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'@UserAnnotation(\n    "key1",\n    items = [\n        @Item("subKey1", description = "Detail information for subKey1 ..."),\n        @Item("subKey2", description = "Detail information for subKey2 ..."),\n        @Item("subKey3", description = "Detail information for subKey3 ...")\n    ]\n)\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'@UserAnnotation(\n    "key1",\n    items = {\n        Item("subKey1", description = "Detail information or subKey1 ..."),\n        Item("subKey2", description = "Detail information for subKey2 ..."),\n        Item("subKey3", description = "Detail information for subKey3 ...")\n    }\n)\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'@UserAnnotation(\n    "key1",\n    items = [\n        Item("subKey1", description = "Detail information for subKey1 ..."),\n        Item("subKey2", description = "Detail information for subKey2 ..."),\n        Item("subKey3", description = "Detail information for subKey3 ...")\n    ]\n)\n')))),(0,i.kt)("p",null,"The above four styles are equivalent. You can freely choose the style you like.  "),(0,i.kt)("h2",{id:"14-practical-applications"},"14. Practical Applications"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"../../query/object-fetcher/dto"},"As output parameters in query APIs ",(0,i.kt)("em",{parentName:"a"},"(optional)")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"../../mutation/save-command/input-dto/dto-lang"},"As input parameters in save APIs ",(0,i.kt)("em",{parentName:"a"},"(required)"))))))}g.isMDXComponent=!0}}]);