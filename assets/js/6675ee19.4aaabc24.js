"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[4557],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=p(n),u=l,k=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=n.length,i=new Array(o);i[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,i[1]=r;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),l=n(34334);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(o,i),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(83117),l=n(67294),o=n(34334),i=n(72389),r=n(67392),s=n(7094),p=n(12466);const c="tabList__CuJ",d="tabItem_LNqP";function m(e){var t;const{lazy:n,block:i,defaultValue:m,values:u,groupId:k,className:b}=e,h=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),N=u??h.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),f=(0,r.l)(N,((e,t)=>e.value===t.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===m?m:m??(null==(t=h.find((e=>e.props.default)))?void 0:t.props.value)??h[0].props.value;if(null!==g&&!N.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${N.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:_,setTabGroupChoices:y}=(0,s.U)(),[T,v]=(0,l.useState)(g),C=[],{blockElementScrollPositionUntilNextRender:O}=(0,p.o5)();if(null!=k){const e=_[k];null!=e&&e!==T&&N.some((t=>t.value===e))&&v(e)}const I=e=>{const t=e.currentTarget,n=C.indexOf(t),a=N[n].value;a!==T&&(O(t),v(a),null!=k&&y(k,String(a)))},B=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=C.indexOf(e.currentTarget)+1;n=C[t]??C[0];break}case"ArrowLeft":{const t=C.indexOf(e.currentTarget)-1;n=C[t]??C[C.length-1];break}}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,o.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},b)},N.map((e=>{let{value:t,label:n,attributes:i}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>C.push(e),onKeyDown:B,onFocus:I,onClick:I},i,{className:(0,o.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":T===t})}),n??t)}))),n?(0,l.cloneElement)(h.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},h.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function u(e){const t=(0,i.Z)();return l.createElement(m,(0,a.Z)({key:String(t)},e))}},32102:(e,t,n)=>{n.d(t,{s:()=>b});var a=n(83117),l=n(67294),o=n(42293),i=n(50657),r=n(6514),s=n(54776),p=n(10155),c=n(15861),d=n(93946),m=n(9137),u=n(61274),k=n(50594);const b=(0,l.memo)((e=>{let{open:t,fullScreen:n=!1,title:a,onClose:s,children:b}=e;const[N,f]=(0,l.useState)(n),g=(0,l.useCallback)((()=>{f((e=>!e))}),[]);return l.createElement(i.Z,{open:t,onClose:s,fullScreen:N,TransitionComponent:h,maxWidth:"md"},l.createElement(o.Z,{sx:{position:"relative"}},l.createElement(p.Z,null,l.createElement(c.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},a),l.createElement(d.Z,{onClick:g,style:{color:"white"}},N?l.createElement(u.Z,null):l.createElement(m.Z,null)),l.createElement(d.Z,{"aria-label":"close",onClick:s,style:{color:"white"}},l.createElement(k.Z,null)))),l.createElement(r.Z,null,b))})),h=l.forwardRef((function(e,t){return l.createElement(s.Z,(0,a.Z)({direction:"up",ref:t},e))}))},39511:(e,t,n)=>{n.d(t,{b:()=>i});var a=n(67294),l=n(83321),o=n(32102);const i=(0,a.memo)((e=>{let{buttonText:t,fullScreen:n=!1,title:i=t,variant:r="contained",children:s}=e;const[p,c]=(0,a.useState)(!1),d=(0,a.useCallback)((e=>{c(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),m=(0,a.useCallback)((()=>{c(!1)}),[]);return a.createElement(a.Fragment,null,a.createElement(l.Z,{"data-is-view-more-button":"true",onClick:d,variant:r,size:"outlined"==r?"small":"medium"},t),a.createElement(o.s,{open:p,onClose:m,title:i,fullScreen:n},s))}))},49525:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>m,toc:()=>k});var a=n(83117),l=(n(67294),n(3905)),o=n(65488),i=n(85162),r=n(39511);const s={toc:[]};function p(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"\u8bfb\u8005\u53ef\u4ee5\u5148\u5ffd\u7565",(0,l.kt)("inlineCode",{parentName:"p"},"\u8fc7\u6ee4\u5668"),"\u8fd9\u4e2a\u6982\u5ff5\uff0c\u5b83\u53ea\u662f\u8ba9\u672c\u6587\u4fdd\u6301\u9ad8\u5ea6\u4e25\u8c28\u7684\u58f0\u660e\uff0c\u800c\u4e0d\u662f\u8fd9\u91cc\u8981\u8ba8\u8bba\u7684\u5185\u5bb9\u3002"),(0,l.kt)("p",null,"\u5982\u679c\u60f3\u8981\u4e86\u89e3\uff0c\u5b83\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#%E5%B1%9E%E6%80%A7%E8%BF%87%E6%BB%A4%E5%99%A8"},"\u672c\u6587\u6700\u540e\u4e00\u7ae0\uff1a\u5c5e\u6027\u8fc7\u6ee4\u5668")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../global-filter"},"\u5168\u5c40\u8fc7\u6ee4\u5668"))))}p.isMDXComponent=!0;const c={sidebar_position:3,title:"Associations"},d=void 0,m={unversionedId:"query/object-fetcher/association",id:"query/object-fetcher/association",title:"Associations",description:"Fetching Associated Objects",source:"@site/docs/query/object-fetcher/association.mdx",sourceDirName:"query/object-fetcher",slug:"/query/object-fetcher/association",permalink:"/jimmer/docs/query/object-fetcher/association",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/query/object-fetcher/association.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Associations"},sidebar:"tutorialSidebar",previous:{title:"Regular Properties",permalink:"/jimmer/docs/query/object-fetcher/props"},next:{title:"Recursive Query",permalink:"/jimmer/docs/query/object-fetcher/recursive"}},u={},k=[{value:"Fetching Associated Objects",id:"fetching-associated-objects",level:2},{value:"Fetching Associated Objects With Only id",id:"fetching-associated-objects-with-only-id",level:3},{value:"Fetching Complete Associated Objects",id:"fetching-complete-associated-objects",level:3},{value:"Fetch All Table-defined Fields",id:"fetch-all-table-defined-fields",level:3},{value:"Differences between allScalarFields and allTableFields",id:"differences-between-allscalarfields-and-alltablefields",level:2},{value:"Special Configurations for Associations",id:"special-configurations-for-associations",level:2},{value:"BatchSize",id:"batchsize",level:3},{value:"Pagination at Association Level",id:"pagination-at-association-level",level:3},{value:"Property-level Filters",id:"property-level-filters",level:3}],b={toc:k};function h(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"fetching-associated-objects"},"Fetching Associated Objects"),(0,l.kt)("p",null,"In ",(0,l.kt)("a",{parentName:"p",href:"./props"},"last doc")," we introduced scalar property fetching. In this doc we discuss association fetching."),(0,l.kt)("h3",{id:"fetching-associated-objects-with-only-id"},"Fetching Associated Objects With Only id"),(0,l.kt)("p",null,"When fetching an association without any parameters, the associated object only has the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$.\n                .allScalarFields()\n                // highlight-next-line\n                .authors()\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                authors()\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"Here ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," fetches the many-to-many association. We did not specify any parameters for ",(0,l.kt)("inlineCode",{parentName:"p"},"authors()"),", meaning fetching only the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property of associated objects."),(0,l.kt)("p",null,"Two SQLs are generated:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects themselves:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere tb_1_.EDITION = ? \n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query for all ",(0,l.kt)("inlineCode",{parentName:"p"},"Author")," objects with only ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," based on association ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors"),":"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.BOOK_ID, /* batch-map key */\n    tb_1_.AUTHOR_ID /* batch-map value */\nfrom BOOK_AUTHOR_MAPPING as tb_1_\n    where tb_1_.BOOK_ID in (?, ?, ?, ?) \n")))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"There are two associations for ",(0,l.kt)("inlineCode",{parentName:"p"},"Book"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors")," is chosen here for a reason. "),(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," is a direct many-to-one association mapped by foreign key. When fetching it with only id and no ",(0,l.kt)(r.b,{buttonText:"filters",variant:"text",mdxType:"ViewMore"},(0,l.kt)(p,{mdxType:"FilterRef"})),", the associated id is just the foreign key ",(0,l.kt)("inlineCode",{parentName:"p"},"store_id")," of the current table. So there would only be one SQL instead of two here."),(0,l.kt)("p",{parentName:"admonition"},"Therefore ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors")," has better demo effect for this example, ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," will be shown in next example.  ")),(0,l.kt)("p",null,"This example illustrates:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The query only needs id of associated objects, and no filters are used (filters will be introduced later)."),(0,l.kt)("p",{parentName:"li"},"Jimmer optimizes this case by querying only the association table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," without querying the ",(0,l.kt)("inlineCode",{parentName:"p"},"AUTHOR")," table.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where tb_1_.BOOK_ID in (?, ?, ?, ?)")," is batch query because the first query returns 4 main objects."),(0,l.kt)("p",{parentName:"li"},"Jimmer uses batch query to solve the ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," problem, same as ",(0,l.kt)("inlineCode",{parentName:"p"},"DataLoader")," in GraphQL."),(0,l.kt)("p",{parentName:"li"},"When a batch becomes too large, jimmer-sql will split it into multiple batches. This will be explained in ",(0,l.kt)("a",{parentName:"p",href:"#batch-size"},"Batch Size")," section below.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Jimmer queries associated objects via additional SQL instead of LEFT JOIN in main query SQL."),(0,l.kt)("p",{parentName:"li"},"This is designed to prevent duplication in query results when joining on collection associations, as such duplications can be devastating for paged queries. "))),(0,l.kt)("p",null,"The printed result is (formatted for readability):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id":3,\n    "name":"Learning GraphQL",\n    "edition":3,\n    "price":51.00,\n    // highlight-next-line  \n    "authors":[\n        {"id":1},\n        {"id":2}\n    ]\n}\n...omit 2nd object...,  \n...omit 3rd object...,\n...omit 4th object...\n')),(0,l.kt)("h3",{id:"fetching-complete-associated-objects"},"Fetching Complete Associated Objects"),(0,l.kt)("p",null,"In this example, we fetch the many-to-one association ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," and specify parameters for ",(0,l.kt)("inlineCode",{parentName:"p"},"store()")," to explicitly request all scalar properties of the associated object."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                // highlight-next-line\n                .store(\n                    BookStoreFetcher.$\n                        // highlight-next-line\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n.createQuery(Book::class) {\n    where(table.edition.eq(3))\n    select(\n        table.fetchBy {\n            allScalarFields()\n            // highlight-next-line\n            store {\n\n                // highlight-next-line\n                allScalarFields()\n            }\n        }\n    )\n}\n.execute()\n")))),(0,l.kt)("p",null,"Two SQLs are generated:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Query for ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"STORE_ID")," values from previous step are deduplicated and there are two values. Query the associated ",(0,l.kt)("inlineCode",{parentName:"p"},"BookStore")," objects for them:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.WEBSITE\nfrom BOOK_STORE tb_1_\nwhere tb_1_.ID in (?, ?) \n")))),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        // highlight-next-line\n        "store": {\n            "id": 1,\n            "name": "O\'REILLY",\n            "website": null\n        }\n    }\n    ...omit other objects\n]\n')),(0,l.kt)("h3",{id:"fetch-all-table-defined-fields"},"Fetch All Table-defined Fields"),(0,l.kt)("p",null,"In some cases all table-defined fields need to be fetched. Use ",(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," for this."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," fetches all properties defined in the table, including all scalar properties and foreign key based one-to-one/many-to-one associations, but not collection associations, one-to-one/many-to-one associations based on join tables, computed properties or view properties."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            BookFetcher.$\n                // highlight-next-line\n                .allTableFields()\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookAllTableFields = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                // highlight-next-line\n                allTableFields()\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"The output is: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        "store": {\n            "id": 1\n        }\n    }\n    ...omit other objects\n]\n')),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Although ",(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," includes foreign key based one-to-one/many-to-one associations, for this example:  "),(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," = ",(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields")," + ",(0,l.kt)("inlineCode",{parentName:"p"},"store")),(0,l.kt)("p",{parentName:"admonition"},"However, only the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property of associated objects is fetched.  "),(0,l.kt)("p",{parentName:"admonition"},"The literal meaning of ",(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," is querying all fields of the current table. When querying only one table, only ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," of associated objects is known since ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," is the foreign key in current table.")),(0,l.kt)("p",null,"In some cases, ",(0,l.kt)("inlineCode",{parentName:"p"},"select(table.fetch(XxxFetcher.$.allTableFields()))")," is equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"select(table)"),". The latter can be seen as a shorthand for the former. "),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Equivalence prerequisite: Associations are not affected by ",(0,l.kt)(r.b,{buttonText:"filters",variant:"text",mdxType:"ViewMore"},(0,l.kt)(p,{mdxType:"FilterRef"})))),(0,l.kt)("p",null,"The simpler equivalent form is:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    // highlight-next-line\n    .select(book)  \n    .execute();\nSystem.out.println(toJson(list)); \n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookAllScalarFields = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        // highlight-next-line\n        select(table)\n    }\n    .execute()\n\n")))),(0,l.kt)("h2",{id:"differences-between-allscalarfields-and-alltablefields"},"Differences between allScalarFields and allTableFields"),(0,l.kt)("p",null,"Since fetching all scalar fields and all table-defined fields are very common, writing each property repeatedly would be tedious. So Jimmer provides two APIs to simplify this process."),(0,l.kt)("p",null,"Note that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields")," only fetches scalar properties, no associations, computed or view properties.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," fetches all fields defined in table, including foreign key based one-to-one/many-to-one associations, but not collections, many-to-one/one-to-one associations based on join tables, computed or view properties."))),(0,l.kt)("p",null,"For ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," discussed in this doc, there is a many-to-one property ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," mapped directly by foreign key instead of through join table. So "),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," = ",(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields")," + ",(0,l.kt)("inlineCode",{parentName:"p"},"store")),(0,l.kt)("p",null,"Here are two examples:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"\nBookTable book = BookTable.$;\n\nList<Book> booksWithScalarFields = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields() \u2776\n        )\n    )\n    .execute();\n\n\nList<Book> booksWithTablesFields = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allTableFields() \u2777\n        )\n    )\n    .execute();\n\nSystem.out.println(booksWithScalarFields);\nSystem.out.println(booksWithTablesFields); \n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val booksWithScalarFields = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields() \u2776\n            }\n        )\n    }\n    .execute()\n\nval booksWithTableFields = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allTableFields() \u2777\n            }\n        )\n    }\n    .execute()\n\nprintln(booksWithScalarFields)\nprintln(booksWithTablesFields)\n")))),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'[ \u2776\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00\n    }\n    ...omit other objects\n]\n[ \u2777\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        "store": {\n            "id": 1\n        }\n    }\n    ...omit other objects\n] \n')),(0,l.kt)("p",null,"Comparing the outputs, ",(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields")," contains only scalar properties without any associations, while ",(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," additionally includes the ",(0,l.kt)("inlineCode",{parentName:"p"},"store")," association based on ",(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields"),"."),(0,l.kt)("h2",{id:"special-configurations-for-associations"},"Special Configurations for Associations"),(0,l.kt)("h3",{id:"batchsize"},"BatchSize"),(0,l.kt)("p",null,"For one-to-many/many-to-many associations, a large number of associated objects may impact application performance. The ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," configuration is provided for management."),(0,l.kt)("p",null,"The following example does not configure ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize"),":"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n                BookFetcher.$.allScalarFields()\n                // highlight-next-line\n                .authors(AuthorFetcher.$.allScalarFields())\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allTableFields()\n                authors {\n                    // highlight-next-line\n                    allScalarFields()\n                }\n            }\n        )\n    }\n.execute()\n")))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"# 1. Query book table to get all BOOK_ID\nselect\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE\nfrom BOOK tb_1_\nwhere tb_1_.EDITION = ?\n\n# 2. Use BOOK_ID from previous step to join query author table\nselect\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?, ?, ?)\n")),(0,l.kt)("p",null,"In the SQL, no ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," is configured so the default will be used. All BOOK_ID will be directly used in the ",(0,l.kt)("inlineCode",{parentName:"p"},"in(...)")," list of the second query."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        "authors": [\n            {\n                "id": 1,\n                "firstName": "Eve",\n                "lastName": "Procello",\n                "gender": "FEMALE"\n            },\n            {\n                "id": 2,\n                "firstName": "Alex",\n                "lastName": "Banks",\n                "gender": "MALE"\n            }\n        ]\n    },\n    ...omit other objects\n]\n\n')),(0,l.kt)("p",null,"In the example above, we see the query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID  \nwhere tb_2_.BOOK_ID in (?, ?, ?, ?)\n")),(0,l.kt)("p",null,"Here, the ",(0,l.kt)("inlineCode",{parentName:"p"},"in")," expression implements batch query to solve ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," problem."),(0,l.kt)("p",null,"If a batch is too large, it will be split into multiple batches based on ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," configuration, such as:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n                BookFetcher.$.allScalarFields()\n                // highlight-next-line\n                .authors(AuthorFetcher.$.allScalarFields(), it -> it.batch(2))\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    // highlight-next-line\n                    batch(2)\n                }) {}\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("admonition",{type:"danger"},(0,l.kt)("p",{parentName:"admonition"},"Here the ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," for ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," is set to 2. Such a small value would cause poor performance, it is only for demo purposes. Please do not use such small values in real projects.")),(0,l.kt)("p",null,"This would cause the ",(0,l.kt)("inlineCode",{parentName:"p"},"in(?, ?, ?, ?)")," to be split into two ",(0,l.kt)("inlineCode",{parentName:"p"},"in(?, ?)"),", and the SQL to fetch associated objects would be split into two."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME, \n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?) \n")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?)\n")),(0,l.kt)("p",null,"In real projects, in most cases ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," would not be configured like this at fetcher level. Instead, use the global configurations in ",(0,l.kt)("inlineCode",{parentName:"p"},"SqlClient"),": "),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"JSqlClient.getDefaultBatchSize()"),": Default ",(0,l.kt)("inlineCode",{parentName:"li"},"batchSize")," for one-to-one and many-to-one associations, default 128"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"JSqlClient.getDefaultListBatchSize()"),": Default ",(0,l.kt)("inlineCode",{parentName:"li"},"batchSize")," for one-to-many and many-to-many associations, default 16")),(0,l.kt)("p",null,"When creating ",(0,l.kt)("inlineCode",{parentName:"p"},"SqlClient"),", the global configs can be changed:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDefaultBatchSize(256) \n    .setDefaultListBatchSize(32)\n    ....\n    build();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val sqlClient = newKSqlClient {\n    setDefaultBatchSize(256)\n    setDefaultListBatchSize(32)\n    ....\n    }\n")))),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"No matter association-level ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," or global ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize"),", do not set above 1000 because Oracle database allows max 1000 values in ",(0,l.kt)("inlineCode",{parentName:"p"},"in(...)"),".")),(0,l.kt)("h3",{id:"pagination-at-association-level"},"Pagination at Association Level"),(0,l.kt)("p",null,"For collection associations, ",(0,l.kt)("inlineCode",{parentName:"p"},"limit(limit, offset)")," can be specified during fetching to do pagination at association level."),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Association-level pagination and batch loading cannot coexist. Association-level pagination necessarily causes ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," problem. Please use this feature cautiously!"),(0,l.kt)("p",{parentName:"admonition"},"If association-level pagination is used, ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," must be set to 1, otherwise exceptions would be thrown. This is designed to make it clear to developers and readers that the code has ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," performance risk.")),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$\n            .allScalarFields()\n            .authors(\n                AuthorFetcher.$.allScalarFields(),\n                // highlight-next-line\n                it -> it.batch(1).limit(/*limit*/ 10, /*offset*/ 90)\n            )\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            // highlight-next-line\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    batch(1)\n                    // highlight-next-line\n                    limit(limit = 90, offset = 10)\n                    }) {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Since association pagination cannot solve ",(0,l.kt)("inlineCode",{parentName:"li"},"N+1")," problem, multiple SQLs are generated"),(0,l.kt)("li",{parentName:"ul"},"For simplicity let's assume ",(0,l.kt)("inlineCode",{parentName:"li"},"H2Dialect")," is used so different databases have the same paging SQL")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query current ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE\nfrom BOOK as tb_1_\nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 1st ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object "),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME, \n    tb_3_.GENDER\nfrom BOOK_AUTHOR_MAPPING as tb_1_  \ninner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID\nwhere tb_1_.BOOK_ID = ?\n/* highlight-next-line */\nlimit ? offset ?  \n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 2nd ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,l.kt)("p",{parentName:"li"},"Same as above, omitted.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 3rd ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object "),(0,l.kt)("p",{parentName:"li"},"Same as above, omitted.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 4th ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,l.kt)("p",{parentName:"li"},"Same as above, omitted."))),(0,l.kt)("h3",{id:"property-level-filters"},"Property-level Filters"),(0,l.kt)("p",null,"When fetching associations, filters can be specified to filter associated objects."),(0,l.kt)("p",null,"Here for comparison, the query selects two columns, both are ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," type. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"Book.authors")," of the first column uses filter"),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"Book.authors")," of the second column does not use filter")),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Tuple2<Book, Book>> books = sqlClient\n    .createQuery(book)\n    .select(\n        // First column  \n        book.fetch(\n            BookFetcher.$\n            .allScalarFields()\n            .authors(\n                AuthorFetcher.$.allScalarFields(),\n\n                // Use filter\n                // highlight-next-line\n                it -> it.filter(args -> {\n                    args.where(args.getTable().firstName().ilike("a"));\n                })\n            )\n        ),\n\n        // Second column\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .authors(\n                    AuthorFetcher.$.allScalarFields()\n                // No filter used\n                )\n        )\n    )\n    .execute();\n'))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples: List<Tuple2<Book, Book>> = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n\n            // First column\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    // Use filter\n                    // highlight-next-line\n                    filter {\n                    where(table.firstName ilike "a")\n                    }\n                }) {\n                    allScalarFields()\n                }\n            },\n\n            // Second column\n            table.fetchBy {\n                allScalarFields()\n                authors { // No filter used  \n                    allScalarFields()\n                }\n            }\n        )\n    }\n.execute()\n')))),(0,l.kt)("p",null,"Three SQLs are generated:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query the two ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects needed for the tuple"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n/* For tuple._1 */  \n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n\n/* For tuple._2 */\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION, \n    tb_1_.PRICE\n\nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For the ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," association of the 4 ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects in column 1, use filter"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    tb_1_.BOOK_ID,\n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME,\n    tb_3_.GENDER\nfrom BOOK_AUTHOR_MAPPING as tb_1_\ninner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID \nwhere\n    tb_1_.BOOK_ID in (?, ?, ?, ?)  \nand\n    /* Use filter here */\n    /* highlight-next-line */\n    lower(tb_3_.FIRST_NAME) like ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For the ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," association of the 4 ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects in column 2, no filter"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    tb_1_.BOOK_ID,\n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME,\n    tb_3_.GENDER\nfrom BOOK_AUTHOR_MAPPING as tb_1_\ninner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID\nwhere\n    tb_1_.BOOK_ID in (?, ?, ?, ?)\n/* No filter here */ \n")))),(0,l.kt)("p",null,"The printed result is (formatted for readability):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'Tuple2{\n    _1={\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n\n        // Filter used, incomplete collection\n        // highlight-next-line\n        "authors":[\n            {\n                "id":2,\n                "firstName":"Alex",\n                "lastName":"Banks",\n                "gender":"MALE" \n            }\n        ]\n    },\n    _2={\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n\n        // No filter, complete collection \n        // highlight-next-line\n        "authors":[\n            {\n                "id":2,\n                "firstName":"Alex",\n                "lastName":"Banks",\n                "gender":"MALE"\n            },{\n                "id":"fd6bb6cf-336d-416c-8005-1ae11a6694b5",\n                "firstName":"Eve",\n                "lastName":"Procello",\n                "gender":"MALE"\n            }\n        ]\n    }\n}\n')),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"Filters can not only filter associated objects, but also sort them. The principle is similar so not demonstrated here. ")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("ol",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For associations satisfying both below conditions, applying filters would cause exceptions:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Many-to-one"),(0,l.kt)("li",{parentName:"ul"},"Not null"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"After field filters are used, ",(0,l.kt)("a",{parentName:"p",href:"../../cache/cache-type/association"},"association cache")," for that field becomes invalid. "),(0,l.kt)("p",{parentName:"li"},"To keep association cache valid, global filters supporting ",(0,l.kt)("a",{parentName:"p",href:"../../cache/multiview-cache"},"multi-view cache")," can be used.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"A common mistake in real development (Java for example) is:"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},'filter(it -> args.getTable().firstName().ilike("a"))')),(0,l.kt)("p",{parentName:"li"},"This creates the condition expression but does not call ",(0,l.kt)("inlineCode",{parentName:"p"},"args.where"),". Filter code not calling either ",(0,l.kt)("inlineCode",{parentName:"p"},"args.where")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"args.orderBy")," is meaningless."),(0,l.kt)("p",{parentName:"li"},"The correct code is:"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},'filter(it -> args.where(args.getTable().firstName().ilike("a")))'))))))}h.isMDXComponent=!0}}]);