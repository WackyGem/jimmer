"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[743],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r=a.createContext({}),u=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(r.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,r=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,m=d["".concat(r,".").concat(h)]||d[h]||c[h]||l;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,i=new Array(l);i[0]=d;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),o=n(34334);const l="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(l,i),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>h});var a=n(83117),o=n(67294),l=n(34334),i=n(72389),s=n(67392),r=n(7094),u=n(12466);const p="tabList__CuJ",c="tabItem_LNqP";function d(e){var t;const{lazy:n,block:i,defaultValue:d,values:h,groupId:m,className:k}=e,g=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=h??g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),v=(0,s.l)(b,((e,t)=>e.value===t.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const T=null===d?d:d??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==T&&!b.some((e=>e.value===T)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${T}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:y}=(0,r.U)(),[I,L]=(0,o.useState)(T),A=[],{blockElementScrollPositionUntilNextRender:N}=(0,u.o5)();if(null!=m){const e=f[m];null!=e&&e!==I&&b.some((t=>t.value===e))&&L(e)}const x=e=>{const t=e.currentTarget,n=A.indexOf(t),a=b[n].value;a!==I&&(N(t),L(a),null!=m&&y(m,String(a)))},O=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=A.indexOf(e.currentTarget)+1;n=A[t]??A[0];break}case"ArrowLeft":{const t=A.indexOf(e.currentTarget)-1;n=A[t]??A[A.length-1];break}}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,l.Z)("tabs-container",p)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":i},k)},b.map((e=>{let{value:t,label:n,attributes:i}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:I===t?0:-1,"aria-selected":I===t,key:t,ref:e=>A.push(e),onKeyDown:O,onFocus:x,onClick:x},i,{className:(0,l.Z)("tabs__item",c,null==i?void 0:i.className,{"tabs__item--active":I===t})}),n??t)}))),n?(0,o.cloneElement)(g.filter((e=>e.props.value===I))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==I})))))}function h(e){const t=(0,i.Z)();return o.createElement(d,(0,a.Z)({key:String(t)},e))}},64124:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>c});var a=n(83117),o=(n(67294),n(3905)),l=n(65488),i=n(85162);const s={sidebar_position:5,title:"Mutable Association Table"},r=void 0,u={unversionedId:"mutation/associations",id:"mutation/associations",title:"Mutable Association Table",description:"Premise of This Article",source:"@site/docs/mutation/associations.mdx",sourceDirName:"mutation",slug:"/mutation/associations",permalink:"/jimmer/docs/mutation/associations",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/mutation/associations.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Mutable Association Table"},sidebar:"tutorialSidebar",previous:{title:"Delete Command",permalink:"/jimmer/docs/mutation/delete-command"},next:{title:"Interceptor",permalink:"/jimmer/docs/mutation/draft-interceptor"}},p={},c=[{value:"Premise of This Article",id:"premise-of-this-article",level:2},{value:"Overview",id:"overview",level:2},{value:"Insert Association",id:"insert-association",level:2},{value:"Reverse Conversion",id:"reverse-conversion",level:2},{value:"Bulk Insert",id:"bulk-insert",level:2},{value:"Check Existence",id:"check-existence",level:2},{value:"Delete Association",id:"delete-association",level:2},{value:"Bulk Delete",id:"bulk-delete",level:2},{value:"Notes",id:"notes",level:2}],d={toc:c};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"premise-of-this-article"},"Premise of This Article"),(0,o.kt)("p",null,"Jimmer supports ",(0,o.kt)("a",{parentName:"p",href:"./trigger"},"triggers"),", including BinLog Triggers and Transaction Triggers. "),(0,o.kt)("p",null,"If using Transaction Triggers, it will cause Jimmer modification operations to generate more complete query statements to simulate triggers."),(0,o.kt)("p",null,"The various scenarios discussed in this article and their respective generated SQL are all based on the premise of not using Transaction Triggers."),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"First, the junction table is hidden by the object model, with no direct corresponding entity type. This problem has been explained in ",(0,o.kt)("a",{parentName:"p",href:"../query/associations"},"Query Junction Table"),", so I won't repeat it here."),(0,o.kt)("p",null,"In addition, in the ",(0,o.kt)("a",{parentName:"p",href:"./save-command"},"Save Command")," section, we introduced the save command. It can compare the existing data in the database with the new data the user wants to save. If a relation attribute based on the junction table has changed, the junction table will be modified."),(0,o.kt)("p",null,"Admittedly, the Save Command feature is very powerful, and modifying the junction table is just a very small part of its capabilities. However, sometimes we just need a simple way to insert or delete data directly from the junction table, we don't need the full capabilities of the Save Command.  "),(0,o.kt)("p",null,"Jimmer allows developers to directly insert and delete data from the junction table in a simpler way."),(0,o.kt)("h2",{id:"insert-association"},"Insert Association"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(BookProps.AUTHORS)\n    // highlight-next-line\n    .save(12L, 3L); \n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(Book::authors)\n    // highlight-next-line\n    .save(12L, 3L)\n")))),(0,o.kt)("p",null,"The generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into\n    BOOK_AUTHOR_MAPPING(\n        /* highlight-next-line */\n        BOOK_ID, AUTHOR_ID  \n    )\n    values (?, ?)\n")),(0,o.kt)("p",null,"This example shows how to use the association property ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.authors")," to operate the junction table."),(0,o.kt)("p",null,"Similarly, we can achieve the same goal through the association property ",(0,o.kt)("inlineCode",{parentName:"p"},"Authors.books"),":"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(AuthorProps.BOOKS) \n    // highlight-next-line\n    .save(3L, 12L);\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(Author::books)\n    // highlight-next-line \n    .save(3L, 12L) \n")))),(0,o.kt)("p",null,"Note that compared to the previous example, the parameter order of the ",(0,o.kt)("inlineCode",{parentName:"p"},"save")," method is different due to the different association direction."),(0,o.kt)("p",null,"The generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into\n    BOOK_AUTHOR_MAPPING(\n        /* highlight-next-line */\n        AUTHOR_ID, BOOK_ID\n    ) \n    values (?, ?)\n")),(0,o.kt)("p",null,"It's easy to see that the order of the insert statement columns is also different."),(0,o.kt)("h2",{id:"reverse-conversion"},"Reverse Conversion"),(0,o.kt)("p",null,"For bidirectional associations, ",(0,o.kt)("inlineCode",{parentName:"p"},"reverse")," can be used to switch between forward and reverse associations:"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Associations bookToAuthor = sqlClient\n    .getAssociations(BookProps.AUTHORS);\nAssociations authorToBook = sqlClient\n    .getAssociations(AuthorProps.BOOKS);\nAssociations authorToBook2 =\n    // highlight-next-line\n    bookToAuthor.reverse(); \nAssociations bookToAuthor2 =\n    // highlight-next-line\n    authorToBook.reverse();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookToAuthor = \n    sqlClient.getAssociations(\n        Book::authors\n    )\nval authorToBook = \n    sqlClient.getAssociations(\n        Author::books  \n    )\nval authorToBook2 =\n    // highlight-next-line\n    bookToAuthor.reverse()\nval bookToAuthor2 =\n    // highlight-next-line \n    authorToBook.reverse()\n")))),(0,o.kt)("p",null,"In this code:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"bookToAuthor")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"bookToAuthor2")," are completely equivalent. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"authorToBook")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"authorToBook2")," are completely equivalent.")),(0,o.kt)("h2",{id:"bulk-insert"},"Bulk Insert"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(BookProps.AUTHORS)\n    // highlight-next-line\n    .batchSave(\n        Arrays.asList(\n            new Tuple2<>(10L, 1L),\n            new Tuple2<>(11L, 1L), \n            new Tuple2<>(12L, 1L),\n            new Tuple2<>(10L, 3L),\n            new Tuple2<>(11L, 3L),\n            new Tuple2<>(12L, 3L)  \n        )\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(\n        Book::authors  \n    )\n    // highlight-next-line \n    .batchSave(\n        listOf(\n            Tuple2(10L, 1L),\n            Tuple2(11L, 1L),\n            Tuple2(12L, 1L),\n            Tuple2(10L, 3L),\n            Tuple2(11L, 3L),\n            Tuple2(12L, 3L)\n        )\n    ) \n")))),(0,o.kt)("p",null,"Here there are 3 books, two authors, and 6 total combination ways. The ",(0,o.kt)("inlineCode",{parentName:"p"},"batchSave")," method inserts all 6 combinations into the junction table, generating the following SQL:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK_AUTHOR_MAPPING(\n    BOOK_ID, AUTHOR_ID\n) values\n    /* highlight-start */\n    (?, ?),\n    (?, ?), \n    (?, ?),\n    (?, ?),\n    (?, ?),\n    (?, ?) \n    /* highlight-end */\n")),(0,o.kt)("p",null,"The above approach is very cumbersome. For ",(0,o.kt)("inlineCode",{parentName:"p"},"3 * 2 = 6")," it is still acceptable, but what about ",(0,o.kt)("inlineCode",{parentName:"p"},"7 * 9 = 63"),"? Should we really construct 63 tuples? "),(0,o.kt)("p",null,"Jimmer-sql provides a shorthand syntax:"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(BookProps.AUTHORS)\n    // Save cartesian product of two id sets  \n    // highlight-next-line\n    .batchSave(\n        Arrays.asList(\n            10L, 11L, 12L\n        ),\n        Arrays.asList(\n            1L, 3L\n        )\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(\n        Book::authors\n    )\n    // Save cartesian product of two id sets\n    // highlight-next-line \n    .batchSave(\n        listOf(10L, 11L, 12L),\n        listOf(1L, 3L)\n    )\n")))),(0,o.kt)("p",null,"The above ",(0,o.kt)("inlineCode",{parentName:"p"},"batchSave")," method takes two collection parameters and inserts the cartesian product of the two collections into the junction table, so its functionality is the same as the previous example."),(0,o.kt)("h2",{id:"check-existence"},"Check Existence"),(0,o.kt)("p",null,"Inserting id tuples that already exist into the junction table will cause errors, as it violates uniqueness constraints."),(0,o.kt)("p",null,"To solve this problem, existence checks can be performed."),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(BookProps.AUTHORS)\n    .batchSaveCommand(\n        Arrays.asList(\n            10L, 11L, 12L\n        ), \n        Arrays.asList(\n            1L, 3L\n        )\n    )\n    // highlight-next-line\n    .checkExistence()\n    .execute();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(\n        Book::authors\n    )\n    // highlight-next-line\n    .batchSave(\n        listOf(10L, 11L, 12L),\n        listOf(1L, 3L),\n        // highlight-next-line\n        checkExistence = true\n    )\n")))),(0,o.kt)("p",null,"Here ",(0,o.kt)("inlineCode",{parentName:"p"},"checkExistence()")," indicates that it will first check which data to be inserted already exists, and then only insert data that does not exist."),(0,o.kt)("p",null,"The generated SQL statements are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Check which data to be inserted already exists:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    BOOK_ID, AUTHOR_ID\nfrom BOOK_AUTHOR_MAPPING\nwhere\n    (BOOK_ID, AUTHOR_ID) in(\n        (?, ?),\n        (?, ?), \n        (?, ?)\n    )\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Using the results of the previous query, the data that really needs to be inserted can be calculated. Skip this step if no data needs to be inserted; otherwise, execute this step."),(0,o.kt)("p",{parentName:"li"},"Here, assuming it is determined that only two rows of data really need to be inserted, the generated SQL is:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK_AUTHOR_MAPPING(\n    BOOK_ID, AUTHOR_ID  \n) values\n    (?, ?),\n    (?, ?)\n")))),(0,o.kt)("h2",{id:"delete-association"},"Delete Association"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(BookProps.AUTHORS)\n    // highlight-next-line\n    .delete(12L, 3L);\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(\n        Book::authors\n    )\n    // highlight-next-line\n    .delete(12L, 3L)\n")))),(0,o.kt)("p",null,"The generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"delete from BOOK_AUTHOR_MAPPING\nwhere\n    (BOOK_ID, AUTHOR_ID) in (\n        (?, ?) \n    )\n")),(0,o.kt)("h2",{id:"bulk-delete"},"Bulk Delete"),(0,o.kt)("p",null,"Similar to bulk insert, there are two ways to bulk delete:"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(\n        BookTableEx.claBookProps.AUTHORS)\n    // highlight-next-line \n    .batchDelete(\n        Arrays.asList(\n            new Tuple2<>(10L, 1L),\n            new Tuple2<>(11L, 1L),\n            new Tuple2<>(12L, 1L),\n            new Tuple2<>(10L, 3L),\n            new Tuple2<>(11L, 3L),\n            new Tuple2<>(12L, 3L), \n        )\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(\n        Book::authors\n    )\n    // highlight-next-line\n    .batchDelete(\n        listOf(\n            Tuple2(10L, 1L),\n            Tuple2(11L, 1L),\n            Tuple2(12L, 1L),\n            Tuple2(10L, 3L),\n            Tuple2(11L, 3L),\n            Tuple2(12L, 3L)\n        )\n    )\n")))),(0,o.kt)("p",null,"Or:"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getAssociations(BookProps.AUTHORS)\n    // highlight-next-line\n    .batchDelete(\n        Arrays.asList(10L, 11L, 12L),\n        Arrays.asList(1L, 3L)\n    ); \n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .getAssociations(\n        Book::authors\n    )\n    // highlight-next-line\n    .batchDelete(\n        listOf(10L, 11L, 12L),\n        listOf(1L, 3L) \n    )\n")))),(0,o.kt)("p",null,"The generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"delete from BOOK_AUTHOR_MAPPING  \nwhere\n    (BOOK_ID, AUTHOR_ID) in (\n        (?, ?),\n        (?, ?)\n    )\n")),(0,o.kt)("h2",{id:"notes"},"Notes"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Please do not abuse this feature. This feature is only suitable for simple insertion and deletion of junction tables. It is recommended to only use it when facing the simplest incremental operations.  ")),(0,o.kt)("p",null,"Let's look at an example. If comparison with existing data in the database is needed, this feature is obviously not the optimal choice, and the code will be very cumbersome, as follows:"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Inappropriate Usage Example"',title:'"Inappropriate',Usage:!0,'Example"':!0},"public void setAuthors(long bookId, Collection<Long> authorIds) {\n\n    // Get old author ids\n    AssociationTable<Book, BookTableEx, Author, AuthorTableEx> table =\n                AssociationTable.of(BookTableEx.class, BookTableEx::authors);    \n    List<Long> oldAuthorIds = sqlClient\n            .createAssociationQuery(table)\n            .where(table.source().id().eq(1L))\n            .select(table.target().id())\n            .execute();\n\n    // Delete `oldAuthorIds - authorIds`\n    List<Long> detachedAuthorIds = new ArrayList<>(oldAuthorIds);\n    detachedAuthorIds.removeAll(authorIds);\n    sqlClient.getAssociations(BookProps.AUTHORS).batchDelete(\n            Collections.singleton(bookId),\n            detachedAuthorIds\n    );\n\n    // Insert `authorIds - oldAuthorIds`\n    List<Long> attachedAuthorIds = new ArrayList<>(authorIds);\n    attachedAuthorIds.removeAll(oldAuthorIds);\n    sqlClient.getAssociations(BookProps.AUTHORS).batchSave(\n            Collections.singleton(bookId),\n            attachedAuthorIds\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Inappropriate Usage Example"',title:'"Inappropriate',Usage:!0,'Example"':!0},"fun setAuthors(bookId: Long, authorIds: Collection<Long>) {\n    // Get old author ids\n    val oldAuthorIds = sqlClient.queries.forList(Book::authors) {\n        where(table.source.id eq bookId)\n        select(table.target.id)\n    }.execute().toSet()\n\n    // Delete `oldAuthorIds - authorIds`\n    sqlClient\n        .getAssociations(Book::authors)\n        .batchDelete(listOf(bookId), oldAuthorIds - authorIds)\n\n    // Insert `authorIds - oldAuthorIds` \n    sqlClient\n        .getAssociations(Book::authors)\n        .batchSave(listOf(bookId), authorIds - oldAuthorIds)\n}\n")))),(0,o.kt)("p",null,"It is obvious that dealing with it this way is very cumbersome.  "),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"When the business scenario is no longer simple addition or deletion, ",(0,o.kt)("a",{parentName:"p",href:"./save-command"},"Save Command")," is a better choice, as follows:")),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Better Usage Example"',title:'"Better',Usage:!0,'Example"':!0},"public void setAuthors(long bookId, Collection<Long> authorIds) {\n    sqlClient.save(\n        BookDraft.$.produce(book -> {\n            book.setId(bookId);\n            book.setAuthorIds(authorIds);\n        })\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Better Usage Example"',title:'"Better',Usage:!0,'Example"':!0},"fun setAuthors(bookId: Long, authorIds: Collection<Long>) {\n    sqlClient.save(\n        new(Book::class).by {\n            id = bookId\n            authorIds = authorIds\n        }\n    )\n}\n")))))}h.isMDXComponent=!0}}]);