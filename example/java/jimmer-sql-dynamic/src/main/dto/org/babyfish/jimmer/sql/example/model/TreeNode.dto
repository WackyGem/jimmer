/*
 * Jimmer is good at solving the troubles caused by the DTO explosion problem to the actual project.
 * In jimmer, DTO is cheap.
 *
 * - For input DTOs used by mutation operations, never use dynamic entity type directly as
 *   `@ResponseBody` parameter, because it allows users to store arbitrarily complex data structures
 *   so that security will be broken. You should always declare the input DTO here, and jimmer will
 *   automatically generate the relevant Java/Kotlin code and let you save it with only one line of code.
 *
 * - For output DTOs used by query operations, jimmer provides you with two choices:
 *
 *   1. Do not define output DTO, return dynamic entities directly.
 *      In this mode, it is recommended to use the `@FetchBy` annotation to decorate the returned
 *      dynamic entity type, when jimmer generates code for the client(eg: TypeScript), those output
 *      DTOs that you have not defined will be defined automatically.
 *
 *   2. Declare the output DTO here, jimmer will automatically generate the relevant Java/Kotlin
 *      code and let you query it costlessly.
 *
 *   ----------------------
 *
 *   This example demonstrates the choice-1, you can view the second choice-2 by
 *   `example/java/jimmer-sql-static` or `example/kotlin/jimmer-sql-static-kt`
 */


input RecursiveTreeInput {

    /*
     * Here, the macro `allScalars` has parameters, that means only the
     * scalar properties of the `Book` interface itself can be mapped automatically,
     * excluding the scalar properties of the super interfaces.
     */
    #allScalars(TreeNode)

    childNodes {
        #allScalars(TreeNode)
    }* // `*` means recursive
}