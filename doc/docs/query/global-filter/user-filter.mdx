---
sidebar_position: 2
title: Custom Filters
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Provide Abstract Entity Superclass

First, provide a `MappedSuperclass` supertype for all entities that need multi-tenancy management to inherit:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="TenantAware.java"
@MappedSuperclass  
public interface TenantAware {

    String tenant();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="TenantAware.kt"
@MappedSuperclass
interface TenantAware {

    val tenant: String
}
```

</TabItem>
</Tabs>

Any entity that needs multi-tenancy support can inherit `TenantAware`, such as `Book`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
@Entity
public interface Book extends TenantAware {

    ...Other code omitted...
} 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"  
@Entity
interface Book : TenantAware {
    
    ...Other code omitted...
}
```

</TabItem>
</Tabs>

:::tip
Certainly, it's possible to apply filters directly to entity types without defining the abstract type. This works fine.

However, it is better to extract the abstract type from entities, so one filter can apply to multiple entity types. 

More importantly, `MappedSuperclass` supports multiple inheritance, i.e. entities can inherit from multiple supertypes. Multi-inheritance combined with global filters brings amazing flexibility.
:::

## Define Filter

Assume there is an object of type `TenantProvider` in the Spring context. Its Java method `get()` and Kotlin property `tenant` are used to extract the tenant of the current operator from identity info. Define the filter as follows:

-   In Java, interceptors need to implement `org.babyfish.jimmer.sql.filter.Filter`.
-   In Kotlin, interceptors need to implement `org.babyfish.jimmer.sql.kt.filter.KFilter`.

If using Spring management, the code is:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Component 
public class TenantFilter implements Filter<TenantAwareProps> {

    private final TenantProvider tenantProvider;

    public TenantFilter(TenantProvider tenantProvider) {
        this.tenantProvider = tenantProvider;
    }

    @Override
    public void filter(FilterArgs<TenantAwareProps> args) {
        String tenant = tenantProvider.get();
        if (tenant != null) {
            args.where(args.getTable().tenant().eq(tenant));
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Component
class TenantFilter(
    private val tenantProvider: TenantProvider  
) : KFilter<TenantAware> {

    override fun filter(args: KFilterArgs<TenantAware>) {
        tenantProvider.tenant?.let {
            args.apply {
                where(table.tenant.eq(it)) 
            }
        }
    }
}
```

</TabItem>
</Tabs>

There are slight differences in filter definition between Java and Kotlin:

-   In Java, the generic type of `Filter` is `TenantAwareProps`, which is part of the code auto-generated by the compiler for the abstract type `TenantAware`.

-   In Kotlin, the generic type of `KFilter` is the abstract type `TenantAware` itself.

`TenantFilter` filters the abstract type `TenantAware`. For any entity that inherits the abstract interface `TenantAware` directly or indirectly, its queries will be handled by this filter, automatically adding a where condition.

Inside `TenantFilter`, it first extracts the tenant of the current operator from identity info. If the tenant is non-null, use it to filter data, querying only data that matches the specified tenant.

### Configure Filter in Spring

In the above, the defined class `TenantFilter` is decorated with `@Component`, obviously a Spring-managed object. 

:::info
If using Jimmer's Spring Boot Starter and ensuring the filter is Spring-managed, Jimmer will auto-register it without extra configuration.

Otherwise, must manually register.
:::

### Configure Filter Without Spring  

Attach the filter to the SqlClient object for it to take effect:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
JSqlClient sqlClient = JSqlBuilder
    .newBuilder()
    // highlight-next-line
    .addFilter(new CustmerFilter())
    ...Other config omitted...
    .build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val sqlClient =
    newKSqlClient {
        // highlight-next-line
        addFilters(new CustmerFilter())
        ...Other config omitted...
    }
```

</TabItem>
</Tabs>

## Filter Aggregate Root Objects

Filtering aggregate roots is the simplest use of global filters.

Since `Book` entity inherits from `TenantAware`, its queries will be affected by this filter.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient.getEntities.findAll(Book.class);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin"> 

```kotlin
val books = sqlClient.entities.findAll(Book::class); 
```

</TabItem>
</Tabs>
or
<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable book = BookTable.$;
List<Book> books = sqlClient
    .createQuery(book) 
    .select(book)
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = SqlClient
    .createQuery(Book::class) {
        select(table) 
    }
    .execute()
```

</TabItem>  
</Tabs>

The generated SQL:

```sql
select
    tb_1_.ID,
    tb_1_.TENANT,
    tb_1_.NAME,
    tb_1_.EDITION, 
    tb_1_.PRICE,
    tb_1_.STORE_ID
from BOOK as tb_1_ 
/* highlight-next-line */
where tb_1_.TENANT = ?
```

Obviously, the query here is very simple without any query parameters. But the final SQL still filters on `tb_1_.TENANT`.

## Filter Associated Objects

Not only aggregate roots can be filtered, associated objects can be filtered too:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
List<Author> authors = sqlClient.getEntities.findAll(
    AuthorFetcher.$
        .allScalarFields()
        // highlight-next-line
        .books(
            BookFetcher.$
                .allScalarFields()
        )
);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient.entities.findAll(
    newFetcher(Author::class).by {
        allScalarFields()
        // highlight-next-line
        books {
            allScalarFields()
        }
    }
); 
```

</TabItem>
</Tabs>
or
<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
AuthorTable author = AuthorTable.$;
List<Author> authors = sqlClient  
    .createQuery(author)
    .select(
        author.fetch(
            AuthorFetcher.$
                .allScalarFields()
                // highlight-next-line
                .books(
                    BookFetcher.$
                        .allScalarFields()
                )
        )
    )
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val authors = SqlClient
    .createQuery(Author::class) {
        select(
            table.fetchBy {
                allScalarFields()
                // highlight-next-line
                books {
                    allScalarFields()
                }
            }
        )
    }
    .execute() 
```

</TabItem>
</Tabs>

This generates two SQL statements:

1.  Query aggregate roots:

    ```sql
    select
        tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME, tb_1_.GENDER
    from AUTHOR as tb_1_
    ```
   
2.  Query associated objects:

    ```sql
    select
        tb_2_.AUTHOR_ID,
        tb_1_.ID,
        tb_1_.TENANT,
        tb_1_.NAME,
        tb_1_.EDITION,
        tb_1_.PRICE
    from BOOK as tb_1_
    inner join BOOK_AUTHOR_MAPPING as tb_2_
        on tb_1_.ID = tb_2_.BOOK_ID
    where
        tb_2_.AUTHOR_ID in (?, ?, ?, ?, ?)
    and
        /* highlight-next-line */  
        tb_1_.TENANT = ? 
    ```
       
##  Disable Filters      

Calling `sqlClient.filters` creates a new temporary SqlClient without affecting the current `sqlClient`, which can be used to disable filters:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
JSqlClient tmpSqlClient = 
    sqlClient.filters(it -> {
        it
            // highlight-next-line
            .disableByTypes(TenantFilter.class);
    });
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val tmpSqlClient =
    sqlClient.filters {
        // highlight-next-line
        disableByTypes(TenantFilter::class)
    }
```

</TabItem> 
</Tabs>

Here we get a temporary `tmpSqlClient`. Queries created from it will ignore the filter we demonstrated above.

## Sharding Filters

Jimmer provides simple APIs to query entity/entities by id/ids. 

By default, these APIs are special - they ignore global filters. Queries by id ignoring filters are correct since ids uniquely identify objects.

However, if [sharding-jdbc](https://shardingsphere.apache.org/document/4.1.1/en/manual/sharding-jdbc/) is used at the JDBC level, and the field used as filter condition is the sharding field in sharding-jdbc, querying by id alone would cause sharding-jdbc to query multiple shards, which is disastrous. 

To solve this, make the filter implement `ShardingFilter` *(Java)* or `KShardingFilter` *(Kotlin)*. These interfaces have no behaviors, just for type marking.

Once a filter inherits `ShardingFilter` or `KShardingFilter`, these simple APIs will no longer ignore the filter. This ensures the final SQL contains the sharding field required by sharding-jdbc, querying only one shard instead of all shards.
