---
sidebar_position: 2
title: External Cache
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Work with any external cache. By default, the framework is just a very lightweight and powerful SQL generator without caching. Still, users can attach any external cache

1. No assumptions are made about the user's cache technology selection, developers can choose any cache technology. The framework only manages and coordinates the cache, and does not do cache implementation.

2. Unlike other ORMs, it supports not only object caching, but also associative caching. The two are combined behind the scenes and can be used with object fetcher to query object trees of any depth and breadth, especially when recursively querying self-associative properties.

For high-performance complex data structure queries, the following two tasks will cause a large workload for developers.

1. Query different data fragments from different caches, and then manually merge them into a whole and return it.

2. Ensure consistency between cache and database.

In order to relieve the developer from these two heavy tasks, the framework's caching mechanism is designed to be powerful enough and transparent to the developer.

## Basic concept

### 1. Object cache

This cache maps ids to entity objects, which are simple objects without associations(Except for id-only parent objects based on foreign key).

![object-cache](@site/static/img/object-cache.jpeg)

### 2. Association property cache

This cache is used for associative properties
- For one-to-one or many-to-one associations, map the current object id to the id of the associated object
- For one-to-many or many-to-many associations, map the current object id to the id list of the associated objects

![association-cache](@site/static/img/association-cache.png)

### 3. Calculated property cache

This cache is used for user-defined calculated properties. 

This cache will be explained in detail in the article [Calculated property and its cache](./calculated-prop), and this article will not pay attention to it.

## Which functions will use the cache?

1. Object fetcher: Except for the root query, the rest of the associations and associated objects will use the cache, which is extremely effective for recursive fetching.
2. GraphQL query: Except for the root query, the rest of the associations and associated objects will use the cache.
3. `findById`, `findByIds` and `findMapByIds` in `sqlClient.entities`.

:::info
Using a cache or not can cause advanced queries like `object fetch` and `GraphQL` to generate very different final SQL. But their final effect is equivalent.
:::

## Create cache

Before configuring the cache for the ORM, the cache object needs to be created first.

jimmer-sql does not make any assumptions about the caching technology that users use. Users can use any caching technology, as long as it is adapted to the `Cache` interface.

```java title="Cache.java"
package org.babyfish.jimmer.sql.cache;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;

public interface Cache<K, V> {

    @Nullable V get(@NotNull K key, @NotNull CacheEnvironment<K, V> env);

    @NotNull Map<K, V> getAll(@NotNull Collection<K> keys, @NotNull CacheEnvironment<K, V> env);

    void delete(@NotNull K key);

    void delete(@NotNull K key, Object reason);

    void deleteAll(@NotNull Collection<K> keys);

    void deleteAll(@NotNull Collection<K> keys, @Nullable Object reason);
}
```

**In fact, users do not need to implement this interface directly, using `ChainCacheBuilder` to create cache instances is a more recommended pattern.**

### ChainCacheBuilder

In practical projects, caches are often multi-level, and ChainCacheBuilder is used to help users quickly build multi-level caches.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
Cache<K, V> cache = new ChainCacheBuilder<>()
    .add(new CaffeineBinder<>(512, Duration.ofSeconds(1)))
    .add(new RedisBinder<>(redisTemplate, type, Duration.ofMinutes(10)))
    .build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val cache = ChainCacheBuilder<Any, Any>()
    .add(CaffeineBinder(512, Duration.ofSeconds(1)))
    .add(RedisBinder(redisTemplate, type, Duration.ofMinutes(10)))
    .build()
```

</TabItem>
</Tabs>

In this example, we build a two-level caches.

- The first-level cache is a memory cache inside the JVM, implemented based on caffeine.

- The second level cache is a sharable distributed memory cache based on redis.

As mentioned above, jimmer-sql does not make any assumptions about the cache technology used by the user. The `CaffeineBinder` and `RedisBinder` in the above code are not the types provided by the framework, but the types implemented by user.

Users can choose their favorite caching technologies at will, and write `Binder` adaptation classes for them. These adaptation types need to implement the interface provided by jimmer-sql: `LoadingBinder` or `SimpleBinder`.

#### 1. LoadingBinder

Some caching technologies, such as `Caffeine` and `Guava`, can determine by themselves whether the queried data already exists, and if not, automatically load it from the database or the next level cache.

For this type of caching technology, its adapter class should implement the interface `LoadingBinder`.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="CaffeineBinder.java"
public class CaffeineBinder<K, V> implements LoadingBinder<K, V> {

    private final int maximumSize;

    private final Duration duration;

    // Caffeine does not support null value, 
    // use `Ref<V>` as a wrapper
    private LoadingCache<K, Ref<V>> loadingCache;

    public CaffeineBinder(int maximumSize, Duration duration) {
        this.maximumSize = maximumSize;
        this.duration = duration;
    }

    @Override
    public void initialize(
        // `chain` tells caffine how to load the non-existing 
        // data from database or next level cache.
        CacheChain<K, V> chain
    ) {
        // Create caffeine cache
        loadingCache = Caffeine
                .newBuilder()
                .maximumSize(maximumSize)
                .expireAfterWrite(duration)
                .build(
                    new CacheLoader<K, Ref<V>>() {

                        @Override
                        public Ref<V> load(K key) {
                            // Load from database or next level cache
                            Map<K, V> map = chain.loadAll(Collections.singleton(key));
                            V value = map.get(key);
                            if (value != null || map.containsKey(key)) {
                                return Ref.of(value);
                            }
                            return null;
                        }

                        @SuppressWarnings("unchecked")
                        @Override
                        public Map<? extends K, ? extends Ref<V>> loadAll(
                            Set<? extends K> keys
                        ) {
                            // Load from database or next level cache
                            Map<K, V> map = chain.loadAll((Collection<K>) keys);
                            return map
                                    .entrySet()
                                    .stream()
                                    .collect(
                                            Collectors.toMap(
                                                    Map.Entry::getKey,
                                                    e -> Ref.of(e.getValue())
                                            )
                                    );
                        }
                    }
                );
    }

    @Override
    public Map<K, V> getAll(Collection<K> keys) {
        Map<K, Ref<V>> map = loadingCache.getAll(keys);
        Map<K, V> convertedMap = new HashMap<>((map.size() * 4 + 2) / 3);
        for (Map.Entry<K, Ref<V>> e : map.entrySet()) {
            convertedMap.put(e.getKey(), e.getValue().getValue());
        }
        return convertedMap;
    }

    @Override
    public void deleteAll(@NotNull Collection<K> keys, Object reason) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or caffeine sub cache.
        if (reason == null || reason.equals("caffeine")) {
            loadingCache.invalidateAll(keys);
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="CaffeineBinder.kt"
class CaffeineBinder<K: Any, V: Any>(
    private val maximumSize: Int, 
    private val duration: Duration
) : LoadingBinder<K, V> {
    
    // Caffeine does not support null value, 
    // use `Ref<V>` as a wrapper
    private lateinit var loadingCache: LoadingCache<K, Ref<V>>
    
    override fun initialize(
        // `chain` tells caffine how to load the non-existing 
        // data from database or next level cache.
        chain: CacheChain<K, V>
    ) {
        // Create caffeine cache
        loadingCache = Caffeine
            .newBuilder()
            .maximumSize(maximumSize.toLong())
            .expireAfterWrite(duration)
            .build(
                object : CacheLoader<K, Ref<V>> {
                    override fun load(key: K): Ref<V>? {
                        // Load from database or next level cache
                        val map = chain.loadAll(setOf(key))
                        val value = map[key]
                        return if (value != null || map.containsKey(key)) {
                            Ref.of(value)
                        } else {
                            null
                        }
                    }

                    override fun loadAll(keys: Set<K>): Map<out K, Ref<V>> =
                        // Load from database or next level cache
                        chain.loadAll((keys as Collection<K>)).mapValues {
                            Ref.of(it.value)
                        }
                }
            )
    }

    override fun getAll(keys: Collection<K>): Map<K, V?> =
        loadingCache.getAll(keys).mapValues {
            it.value.value
        }

    override fun deleteAll(keys: Collection<K>, reason: Any?) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or caffeine sub cache.
        if (reason === null || reason == "caffeine") {
            loadingCache.invalidateAll(keys)
        }
    }
}
```

</TabItem>
</Tabs>

#### 2. SimpleBinder

Some caching technologies, such as `Redis`, only support get/set operations, requiring developers to determine whether the queried data already exists, and if not, the developers load it from the database or the next-level cache.

For this type of caching technology, the adapter class should implement the interface `SimpleBinder`.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="RedisBinder.java"
public class RedisBinder<K, V> implements SimpleBinder<K, V> {

    private static final Logger LOGGER = LoggerFactory.getLogger(RedisBinder.class);

    private final RedisOperations<String, byte[]> operations;

    private final String keyPrefix;

    private final Duration duration;

    private final int randomPercent;

    // For cached values, don't use spring-redis's RedisSerializer, 
    // use `org.babyfish.jimmer.sql.cache.ValueSerializer`.
    // 
    // Its internal work has a certain complexity, 
    // and it is not easy to be implemented by user.
    private final ValueSerializer<V> valueSerializer;

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableType type,
            Duration duration
    ) {
        this(operations, type, duration, 30);
    }

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableProp prop,
            Duration duration
    ) {
        this(operations, prop, duration, 30);
    }

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableProp prop,
            Duration duration,
            int randomPercent
    ) {
        this(operations, null, prop, duration, randomPercent);
    }

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableType type,
            Duration duration,
            int randomPercent
    ) {
        this(operations, type, null, duration, randomPercent);
    }

    private RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableType type,
            ImmutableProp prop,
            Duration duration,
            int randomPercent
    ) {
        if ((type == null) == (prop == null)) {
            throw new IllegalArgumentException("Illegal metadata");
        }
        if (randomPercent < 0 || randomPercent > 100) {
            throw new IllegalArgumentException("randomPercent must between 0 and 100");
        }
        this.operations = operations;
        if (type != null) {
            // Prefix for object, for example: 'Book-'
            this.keyPrefix = type.getJavaClass().getSimpleName() + '-';
        } else {
            // Prefix for property, for example: 'Book.authors-'
            this.keyPrefix = 
                prop.getDeclaringType().getJavaClass().getSimpleName() + 
                '.' + 
                prop.getName() + 
                '-';
        }
        this.duration = duration;
        this.randomPercent = randomPercent;
        if (type != null) {
            valueSerializer = new ValueSerializer<>(type);
        } else {
            valueSerializer = new ValueSerializer<>(prop);
        }
    }

    // How to read value from redis
    @Override
    public Map<K, V> getAll(Collection<K> keys) {
        List<byte[]> values = operations
            .opsForValue()
            .multiGet(
                keys.stream()
                .map(it -> keyPrefix + it)
                .collect(Collectors.toList())
            );
        return valueSerializer.deserialize(keys, values);
    }

    // How to set value into redis
    @SuppressWarnings("unchecked")
    @Override
    public void setAll(Map<K, V> map) {
        Map<String, byte[]> convertedMap = 
            valueSerializer.serialize(map, key -> keyPrefix + key);
        if (LOGGER.isInfoEnabled()) {
            LOGGER.info("save into redis: {}", convertedMap.keySet());
        }
        long millis = duration.toMillis();
        long min = millis - randomPercent * millis / 100;
        long max = millis + randomPercent * millis / 100;
        ThreadLocalRandom random = ThreadLocalRandom.current();
        operations.executePipelined(
                new SessionCallback<Void>() {
                    @Override
                    public <XK, XV> Void execute(
                        RedisOperations<XK, XV> pops
                    ) throws DataAccessException {
                        RedisOperations<String, byte[]> pipelinedOps = 
                            (RedisOperations<String, byte[]>)pops;
                        pipelinedOps.opsForValue().multiSet(convertedMap);
                        for (String key : convertedMap.keySet()) {
                            pipelinedOps.expire(
                                    key,
                                    random.nextLong(min, max),
                                    TimeUnit.MILLISECONDS
                            );
                        }
                        return null;
                    }
                }
        );
    }

    @Override
    public void deleteAll(Collection<K> keys, Object reason) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or redis sub cache.
        if (reason == null || reason.equals("redis")) {
            Collection<String> redisKeys = 
                keys
                    .stream()
                    .map(it -> keyPrefix + it)
                    .collect(Collectors.toList());
            LOGGER.info("delete from redis: {}", redisKeys);
            operations.delete(redisKeys);
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java title="RedisBinder.kt"
class RedisBinder<K, V> private constructor(
    operations: RedisOperations<String, ByteArray>,
    type: ImmutableType?,
    prop: ImmutableProp?,
    duration: Duration,
    randomPercent: Int
) : SimpleBinder<K, V> {

    private val operations: RedisOperations<String, ByteArray>

    private val keyPrefix: String

    private val duration: Duration

    private val randomPercent: Int

    // For cached values, don't use spring-redis's RedisSerializer, 
    // use `org.babyfish.jimmer.sql.cache.ValueSerializer`.
    // 
    // Its internal work has a certain complexity, 
    // and it is not easy to be implemented by user.
    private var valueSerializer: ValueSerializer<V>

    init {
        require(type == null != (prop == null)) { 
            "Illegal metadata" 
        }
        require(!(randomPercent < 0 || randomPercent > 100)) { 
            "randomPercent must between 0 and 100" 
        }
        this.operations = operations
        keyPrefix = if (type != null) {
            // Prefix for object, for example: 'Book-'
            "${type.javaClass.simpleName}-"
        } else {
            // Prefix for property, for example: 'Book.authors-'
            "${prop!!.declaringType.javaClass.simpleName}.${prop.name}-"
        }
        this.duration = duration
        this.randomPercent = randomPercent
        valueSerializer = type
            ?.let { ValueSerializer(it) } 
            ?: ValueSerializer(prop!!)
    }

    constructor(
        operations: RedisOperations<String, ByteArray>,
        type: ImmutableType,
        duration: Duration,
        randomPercent: Int = 30
    ) : this(operations, type, null, duration, randomPercent)

    constructor(
        operations: RedisOperations<String, ByteArray>,
        prop: ImmutableProp,
        duration: Duration,
        randomPercent: Int = 30
    ) : this(operations, null, prop, duration, randomPercent)

    // How to read value from redis
    override fun getAll(keys: Collection<K>): Map<K, V> {
        val values = operations.opsForValue().multiGet(
            keys.map { "$keyPrefix$it" }
        )
        return valueSerializer.deserialize(keys, values!!)
    }

    // How to set value into redis
    @Suppress("UNCHECKED_CAST")
    override fun setAll(map: Map<K, V>) {
        val convertedMap = valueSerializer.serialize(map) { "$keyPrefix$it" }
        if (LOGGER.isInfoEnabled) {
            LOGGER.info("save into redis: {}", convertedMap.keys)
        }
        val millis = duration.toMillis()
        val min = millis - randomPercent * millis / 100
        val max = millis + randomPercent * millis / 100
        val random = ThreadLocalRandom.current()
        operations.executePipelined(
            object : SessionCallback<Void?> {
                override fun <XK, XV> execute(pops: RedisOperations<XK, XV>): Void? {
                    val pipelinedOps = pops as RedisOperations<String, ByteArray>
                    pipelinedOps.opsForValue().multiSet(convertedMap)
                    for (key in convertedMap.keys) {
                        pipelinedOps.expire(
                            key,
                            random.nextLong(min, max),
                            TimeUnit.MILLISECONDS
                        )
                    }
                    return null
                }
            }
        )
    }

    override fun deleteAll(keys: Collection<K>, reason: Any?) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or redis sub cache.
        if (reason === null || reason == "redis") {
            val redisKeys: Collection<String> = keys.map { "$keyPrefix$it" }
            LOGGER.info("delete from redis: {}", redisKeys)
            operations.delete(redisKeys)
        }
    }

    companion object {
        private val LOGGER = LoggerFactory.getLogger(RedisBinder::class.java)
    }
}
```

</TabItem>
</Tabs>

## Configure cache

### Build RedisTemplate

In this example, our second level cache uses redis, so we need to create a `RedisTemplate` first

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public RedisTemplate<String, byte[]> rawDataRedisTemplate(
    // Inject connection factory of spring data redis
    RedisConnectionFactory connectionFactory
) {
    RedisTemplate<String, byte[]> template = new RedisTemplate<>();
    template.setConnectionFactory(connectionFactory);
    template.setKeySerializer(StringRedisSerializer.UTF_8);

    // Specify a dummy serializer for spring redis because 
    // `org.babyfish.jimmer.sql.example.cache.ValueSerializer` took over the job.
    template.setValueSerializer(
            new RedisSerializer<byte[]>() {
                @Override
                public byte[] serialize(byte[] bytes) throws SerializationException {
                    return bytes;
                }
                @Override
                public byte[] deserialize(byte[] bytes) throws SerializationException {
                    return bytes;
                }
            }
    );
    return template;
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun rawDataRedisTemplate(
    // Inject connection factory of spring data redis
    connectionFactory: RedisConnectionFactory
): RedisTemplate<String, ByteArray> =
    RedisTemplate<String, ByteArray>().apply {
        setConnectionFactory(connectionFactory)
        keySerializer = StringRedisSerializer.UTF_8

        // Specify a dummy serializer for spring redis because
        // `org.babyfish.jimmer.sql.example.cache.ValueSerializer` took over the job.
        valueSerializer =
            object : RedisSerializer<ByteArray?> {
                override fun serialize(t: ByteArray?): ByteArray? = t
                override fun deserialize(bytes: ByteArray?): ByteArray? = bytes
            }
    }
```

</TabItem>
</Tabs>

There are two ways to configure cache for jimmer-sql, explicit configuration and implicit configuration.

### Explicit configuration

#### 1. Configure object cache

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public JSqlClient sqlClient(
    RedisTemplate<String, byte[]> redisTemplate
) {
    return JSqlClient
        .newBuilder()
        .setCaches(it -> {
            // highlight-next-line
            it.setObjectCache(
                Book.class,
                new ChainCacheBuilder<>()
                    .add(
                        new CaffeineBinder<>(
                            512, 
                            Duration.ofSeconds(1)
                        )
                    )
                    .add(
                        new RedisBinder<>(
                            redisTemplate, 
                            type, 
                            Duration.ofMinutes(10)
                        )
                    )
                    .build()
            );
        })
        ...omit other configuration...
        .build()
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun sqlClient(
    redisTemplate: RedisTemplate<String, ByteArray>
): KSqlClient =
    newKSqlClient {
        setCaches {
            // highlight-next-line
            setObjectCache(
                Book::class,
                ChainCacheBuilder<Any, Any>()
                .add(
                    CaffeineBinder(
                        512, 
                        Duration.ofSeconds(1)
                    )
                )
                .add(
                    RedisBinder(
                        redisTemplate, 
                        type, 
                        Duration.ofMinutes(10)
                    )
                )
                .build()
            )
        }
        ...omit other configuration...
    }
```

</TabItem>
</Tabs>

#### 2. Configure reference association cache

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public JSqlClient sqlClient(
    RedisTemplate<String, byte[]> redisTemplate
) {
    return JSqlClient
        .newBuilder()
        .setCaches(it -> {
            // highlight-next-line
            it.setAssociatedIdCache(
                BookProps.STORE,
                new ChainCacheBuilder<>()
                    .add(
                        new CaffeineBinder<>(
                            512, 
                            Duration.ofSeconds(1)
                        )
                    )
                    .add(
                        new RedisBinder<>(
                            redisTemplate, 
                            type, 
                            Duration.ofMinutes(5)
                        )
                    )
                    .build()
            );
        })
        ...omit other configuration...
        .build()
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun sqlClient(
    redisTemplate: RedisTemplate<String, ByteArray>
): KSqlClient =
    newKSqlClient {
        setCaches {
            // highlight-next-line
            setAssociatedIdCache(
                Book::store,
                ChainCacheBuilder<Any, Any>()
                .add(
                    CaffeineBinder(
                        512, 
                        Duration.ofSeconds(1)
                    )
                )
                .add(
                    RedisBinder(
                        redisTemplate, 
                        type, 
                        Duration.ofMinutes(5)
                    )
                )
                .build()
            )
        }
        ...omit other configuration...
    }
```

</TabItem>
</Tabs>

#### 3. Configure list association cache

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public JSqlClient sqlClient(
    RedisTemplate<String, byte[]> redisTemplate
) {
    return JSqlClient
        .newBuilder()
        .setCaches(it -> {
            // highlight-next-line
            it.setAssociatedIdListCache(
                BookProps.AUTHORS,
                new ChainCacheBuilder<Object, List<?>>()
                    .add(
                        new CaffeineBinder<>(
                            512, 
                            Duration.ofSeconds(1)
                        )
                    )
                    .add(
                        new RedisBinder<>(
                            redisTemplate, 
                            type, 
                            Duration.ofMinutes(5)
                        )
                    )
                    .build()
            );
        })
        ...omit other configuration...
        .build()
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun sqlClient(
    redisTemplate: RedisTemplate<String, ByteArray>
): KSqlClient =
    newKSqlClient {
        setCaches {
            // highlight-next-line
            setAssociatedIdListCache(
                Book::authors,
                ChainCacheBuilder<Any, List<Any>>()
                .add(
                    CaffeineBinder(
                        512, 
                        Duration.ofSeconds(1)
                    )
                )
                .add(
                    RedisBinder(
                        redisTemplate, 
                        type, 
                        Duration.ofMinutes(5)
                    )
                )
                .build()
            )
        }
        ...omit other configuration...
    }
```

</TabItem>
</Tabs>

#### 4. Configure calculated cache

This cache will be explained in detail in the article [Calculated property and its cache](./calculated-prop), and this article will not pay attention to it.

### Implicit configuration (recommended)

From the previous description, we can specify an object cache for any type, and an association cache for any property.

However, in actual projects, there may be many entity types and association properties, and configuring them one by one will be very tedious. Implicit configuration can handle this situation well.

Implicit configuration requires the help of the interface `CacheFactory`

```java
public interface CacheFactory {

    @Nullable
    default Cache<?, ?> createObjectCache(
        @NotNull ImmutableType type
    ) {
        return null;
    }

    @Nullable
    default Cache<?, ?> createAssociatedIdCache(
        @NotNull ImmutableProp prop
    ) {
        return null;
    }

    @Nullable
    default Cache<?, List<?>> createAssociatedIdListCache(
        @NotNull ImmutableProp prop
    ) {
        return null;
    }

    @Nullable
    default Cache<?, ?> createResolverCache(
        @NotNull ImmutableProp prop
    ) {
        return null;
    }
}
```

The usage is as follows

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public JSqlClient sqlClient(
    RedisTemplate<String, byte[]> redisTemplate
) {
    return JSqlClient
        .newBuilder()
        .setCaches(it -> {
            // highlight-next-line
            setCacheFactory(
                
                // Use this array to iterate types, 
                // association properties, and calculated properties.
                new Class[] {
                    BookStore.class,
                    Book.class,
                    Author.class,
                    TreeNode.class
                }

                // For each type and property, create optional cache.
                return new CacheFactory() {

                    // Create object cache for types, including:
                    // `BookStore`
                    // `Book`
                    // `Author`
                    /// `TreeNode` 
                    @Override
                    public Cache<?, ?> createObjectCache(ImmutableType type) {
                        return new ChainCacheBuilder<>()
                                .add(
                                    new CaffeineBinder<>(
                                        512, 
                                        Duration.ofSeconds(1)
                                    )
                                )
                                .add(
                                    new RedisBinder<>(
                                        redisTemplate, 
                                        type, 
                                        Duration.ofMinutes(10)
                                    )
                                )
                                .build();
                    }

                    // Create reference association cache for 
                    // one-to-one/many-to-one properties, including:
                    // `Book.store`
                    // `TreeNode.parent`
                    @Override
                    public Cache<?, ?> createAssociatedIdCache(ImmutableProp prop) {
                        return new ChainCacheBuilder<>()
                                .add(
                                    new CaffeineBinder<>(
                                        512, 
                                        Duration.ofSeconds(1)
                                    )
                                )
                                .add(
                                    new RedisBinder<>(
                                        redisTemplate, 
                                        prop, 
                                        Duration.ofMinutes(5)
                                    )
                                )
                                .build();
                    }

                    // Create list association cache for 
                    // one-to-many/many-to-many properties, including:
                    // `BookStore.books`
                    // `Book.authors`
                    // `Author.books`
                    // `TreeNode.childNodes`
                    @Override
                    public Cache<?, List<?>> createAssociatedIdListCache(ImmutableProp prop) {
                        return new ChainCacheBuilder<Object, List<?>>()
                                .add(
                                    new CaffeineBinder<>(
                                        64, 
                                        Duration.ofSeconds(1)
                                    )
                                )
                                .add(
                                    new RedisBinder<>(
                                        redisTemplate, 
                                        prop, 
                                        Duration.ofMinutes(5)
                                    )
                                )
                                .build();
                    }

                    // `createResolverCache` is not overridden,
                    // it always returns null, because
                    // calculated property cache will not be 
                    // discussed in this article.
                }
            );
        })
        ...omit other configuration...
        .build()
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun sqlClient(
    redisTemplate: RedisTemplate<String, ByteArray>
): KSqlClient =
    newKSqlClient {
        setCaches {
            // highlight-next-line
            setCacheFactory(

                // Use this array to iterate types, 
                // association properties, and calculated properties.
                arrayOf(
                    BookStore.class,
                    Book.class,
                    Author.class,
                    TreeNode.class
                ),

                // For each type and property, create optional cache.
                object : CacheFactory {

                    // Create object cache for types, including:
                    // `BookStore`
                    // `Book`
                    // `Author`
                    /// `TreeNode` 
                    override fun createObjectCache(type: ImmutableType): Cache<*, *>? =
                        ChainCacheBuilder<Any, Any>()
                            .add(
                                CaffeineBinder(
                                    512, 
                                    Duration.ofSeconds(1)
                                )
                            )
                            .add(
                                RedisBinder(
                                    redisTemplate, 
                                    type, 
                                    Duration.ofMinutes(10)
                                )
                            )
                            .build()

                    // Create reference association cache for 
                    // one-to-one/many-to-one properties, including:
                    // `Book.store`
                    // `TreeNode.parent`
                    override fun createAssociatedIdCache(prop: ImmutableProp): Cache<*, *>? =
                        ChainCacheBuilder<Any, Any>()
                            .add(
                                CaffeineBinder(
                                    512, 
                                    Duration.ofSeconds(1)
                                )
                            )
                            .add(
                                RedisBinder(
                                    redisTemplate, 
                                    prop, 
                                    Duration.ofMinutes(5)
                                )
                            )
                            .build()

                    // Create list association cache for 
                    // one-to-many/many-to-many properties, including:
                    // `BookStore.books`
                    // `Book.authors`
                    // `Author.books`
                    // `TreeNode.childNodes`
                    override fun createAssociatedIdListCache(prop: ImmutableProp): Cache<*, List<*>>? =
                        ChainCacheBuilder<Any, List<*>>()
                            .add(
                                CaffeineBinder(
                                    64, 
                                    Duration.ofSeconds(1)
                                )
                            )
                            .add(
                                RedisBinder(
                                    redisTemplate, 
                                    prop, 
                                    Duration.ofMinutes(5)
                                )
                            )
                            .build()

                    // `createResolverCache` is not overridden,
                    // it always returns null, because
                    // calculated property cache will not be 
                    // discussed in this article.
                }
            )
        }
        ...omit other configuration...
    }
```

</TabItem>
</Tabs>

### Explicit configuration overrides implicit configuration

While implicit configuration, which configures the cache for all types and all properties at once, is the recommended way, explicit configuration also has value.

If there are cache configurations in both explicit and implicit configurations for a type or property, the explicit configuration takes precedence.
While implicit configuration, which configures the cache for all types and all properties at once, is the recommended way, explicit configuration also has value.

If there are cache configurations in both explicit and implicit configurations for a type or property, the explicit configuration takes precedence.

## Data consistency

The framework provides a solution to automatically guarantee consistency between databases and caches.

### Enable trigger

To guarantee data consistency, [Trigger](../advanced/trigger) must be used. 

For cache consistency maintenance, it is recommended to enable [BinLog trigger](../advanced/trigger#enable-binlog-trigger)

:::tip
Once you make sure that [trigger](../advanced/trigger) is enabled, data consistency can be guaranteed automatically.
:::

### Experience data consistency

So far, all the functions we have introduced are query-related, and modification-related functions have not been discussed yet.

To simplify the discussion, assume that the enabled trigger is [BinLog trigger](../advanced/trigger#enable-binlog-trigger). Subsequent discussions can bypass the application to directly modify the database using any SQL tool.

#### 1. Modify foreign key

Use any SQL tool to execute
```sql
update book set store_id = 2 where id = 4
```

Assuming that the foreign key before modification is 1, the log print result is as follows:

```
delete from redis: [Book-4]
delete from redis: [BookStore.books-1]
delete from redis: [BookStore.books-2]
delete from redis: [Book.store-4]
```

This indicates
- Object cache for `Book` with id 4 is deleted
- The association cache for the one-to-many association `BookStore.books` of `BookStore` with id 1 is deleted
- The association cache for the one-to-many association `BookStore.books` of `BookStore` with id 2 is deleted
- The association cache for the many-to-one association `Book.store` of `Book` with id 4 is deleted

#### 2. Modify many-to-many association middle table

Use any SQL tool to execute
```sql
insert into book_author_mapping(
    book_id, author_id
) values(
    1, 4
)
```

the log print result is as follows:
```
delete from redis: [Book.authors-1]
delete from redis: [Author.books-4]
```

This indicates
- The association cache for the many-to-many association `Book.authors` of `Book` with id 1 is deleted
- The association cache for the many-to-many association `Author.books` of `Author` with id 4 is deleted
