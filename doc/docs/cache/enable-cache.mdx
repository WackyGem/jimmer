---
sidebar_position: 1
title: Enable Cache
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import { ViewMore } from '@site/src/components/ViewMore';
import { ObjectCache, AssociationCache, CalculatedCache } from "@site/src/components/Image";

## CacheFactory Interface 

To enable cache, you first need to implement the `CacheFactory` interface, which is defined as follows:

```java title="CacheFactory.java"
package org.babyfish.jimmer.sql.cache;

import org.babyfish.jimmer.meta.ImmutableProp;
import org.babyfish.jimmer.meta.ImmutableType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.List;

public interface CacheFactory {

    @Nullable
    default Cache<?, ?> createObjectCache(@NotNull ImmutableType type) {
        return null;
    }

    @Nullable
    default Cache<?, ?> createAssociatedIdCache(@NotNull ImmutableProp prop) {
        return null;
    }

    @Nullable
    default Cache<?, List<?>> createAssociatedIdListCache(@NotNull ImmutableProp prop) {
        return null;
    }

    @Nullable
    default Cache<?, ?> createResolverCache(@NotNull ImmutableProp prop) {
        return null;
    }
}
```

:::info
For Kotlin, to generate better override method code when overriding `createAssociatedIdListCache`, implement the `org.babyfish.jimmer.sql.kt.cache.KCacheFactory` interface. 

Otherwise, the return type of the override method generated by the IDE will be `Cache<*, MutableList<*>>` instead of the expected `Cache<*, List<*>>`.
:::

Jimmer calls this interface to initialize the cache system. Users implement this interface to answer:

-   createObjectCache: Enable object cache

    The parameter specifies an entity type. If you want to enable object cache for it, create and return the cache; otherwise, return null.

    <ViewMore buttonText="Object cache"><ObjectCache/></ViewMore> refers to mapping id to entity object.
    
    :::note
    The entity object is orphaned. Except for the associated objects of the foreign keys corresponding to the current table's one-to-one *(or one-to-one)* associations that are represented as associated objects with only id, there are no other association properties.
    :::

-   createAssociatedIdCache and createAssociatedIdListCache: Enable association cache

    Both `createAssociatedIdCache` and `createAssociatedIdListCache` are used to enable association cache. The only difference between them is that the former is for one-to-one or many-to-one associations, while the latter is for one-to-many or many-to-many associations.

    The parameter specifies an [association property](../mapping/base/association). If you want to enable association cache for it, create and return the cache; otherwise return null.

    <ViewMore buttonText="Association cache"><AssociationCache/></ViewMore> refers to mapping id to associated id(or their collection).

-   createResolverCache: Enable calculated cache

    The parameter specifies a [complex calculated property](../mapping/advanced/calculated/transient). If you want to enable calculated cache for it, create and return the cache; otherwise, return null.

    <ViewMore buttonText="Computed cache"><CalculatedCache/></ViewMore> refers to mapping id to calculated result.

## Multi-level Cache Architecture

The return type of all methods of the `CacheFactory` interface is `org.babyfish.jimmer.sql.cache.Cache<K, V>`.

Users do not need to directly implement `Cache<K, V>`, but need to use `org.babyfish.jimmer.sql.cache.chain.ChainCacheBuilder` to build multi-level caches.

In theory, `ChainCacheBuilder` supports caches of any number of levels. However, in most projects, two levels of cache are sufficient, for example:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
return new CacheFactory() {

    @Override
    @Nullable
    public Cache<?, ?> createObjectCache(@NotNull ImmutableType type) {
        return new ChainCacheBuilder<>()
            .add( ❶
                new CaffeineBinder<>(512, Duration.ofSeconds(1))
            )
            .add( ❷
                new RedisValueBinder<>(
                    redisTemplate, 
                    objectMapper, 
                    type, 
                    Duration.ofMinutes(10)
                )
            )
            .build();
    }
};
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
return object: KCacheFactory {

    override fun createObjectCache(type: ImmutableType): Cache<*, *>? =
        ChainCacheBuilder<Any, Any>()
            .add( ❶
                CaffeineBinder(512, Duration.ofSeconds(1))
            )
            .add( ❷
                RedisValueBinder(
                    redisTemplate, 
                    objectMapper, 
                    type, 
                    Duration.ofMinutes(10)
                )
            )
            .build()
}
```

</TabItem>
</Tabs>

-   ❶ Indicates first level cache based on [Caffeine](https://github.com/ben-manes/caffeine) in-process JVM cache.

-   ❷ Indicates second level cache based on [Redis](https://redis.io/) remote cache.

As we can see, `ChainCacheBuilder` uses chain programming style. Calling the `add` method multiple times can build multi-level caches.

The `ChainCacheBuilder.add` method is defined as follows:

```java
public class ChainCacheBuilder<K, V> {
    
    public ChainCacheBuilder<K, V> add(LoadingBinder<K, V> binder) { ❶
        ...omit code...
        return this;
    }

    public ChainCacheBuilder<K, V> add(LoadingBinder.Parameterized<K, V> binder) { ❷
        ...omit code...
        return this;
    }

    public ChainCacheBuilder<K, V> add(SimpleBinder<K, V> binder) { ❸
        ...omit code...
        return this;
    }

    ...omit other code...
}
```

-   ❶ `org.babyfish.jimmer.sql.cache.chain.LoadingBinder` is an interface. Any cache technology that automatically loads values on first access to a key can be adapted through this interface.

    Almost all in-process JVM caches have automatic loading capabilities, such as [Caffeine](https://github.com/ben-manes/caffeine) or Guava Cache used in the above code.

-   ❷ The code is only used by [multi-view caches](./multiview-cache). Readers can ignore it for now.

-   ❸ `org.babyfish.jimmer.sql.cache.chain.SimpleBinder` is an interface. Any cache technology without automatic value loading behavior can be adapted through this interface.

    Almost all remote caches do not have automatic loading capabilities, such as [Redis](https://redis.io/) used in the above code.

:::tip
Any cache technology can be adapted to the abstract interfaces `LoadingBinder` or `SimpleBinder`. Therefore, in Jimmer's multi-level cache architecture, no assumptions or restrictions are made on the choice of cache technology at any level.
:::

If using Jimmer's SpringBoot Starter, you can use the following three cache technology adapter classes, as in the code above:

|Adapter Class|Implemented Interface|Supports Multi-view Cache|
|-|-|-|
|org.babyfish.jimmer.spring.cache.CaffeineBinder|org.babyfish.jimmer.sql.cache.chain.LoadingBinder|No|
|org.babyfish.jimmer.spring.cache.RedisValueBinder|org.babyfish.jimmer.sql.cache.chain.SimpleBinder|No| 
|org.babyfish.jimmer.spring.cache.RedisHashBinder|org.babyfish.jimmer.sql.cache.chain.SimpleBinder.Parameterized|Yes|

:::note
[Multi-view caches](./multiview-cache) will be explained in a subsequent article. Please ignore them for now.
:::

## Configuring `CacheFactory` 

Now we have introduced the `CacheFactory` interface and multi-level cache architecture, but there is one last step to enable cache.

The last step is to register `CacheFactory` for Jimmer. 

### SpringBoot Configuration

If using SpringBoot Starter, just let `CacheFactory` be managed by Spring.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
// highlight-next-line
@Bean
public CacheFactory cacheFactory() {
    return new CacheFactory() {
        ...omit code...
    };
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
// highlight-next-line
@Bean
fun cacheFactory(): KCacheFactory =
    object: KCacheFactory {
        ...omit code...
    }
```

</TabItem>
</Tabs>

### Underlying API Configuration

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
JSqlClient sqlClient = JSqlClient
    .newBuilder()
    .setCacheFactory(
        new CacheFactory() {
                ...omit code...
        }
    )
    ...omit other configuration...
    .build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val sqlClient = newKSqlClient {
    setCacheFactory(
        object: KCacheFactory {
            ...omit code...
        }
    )
    ...omit other configuration...
}
```

</TabItem>
</Tabs>

## Redis Cache Helper APIs

Earlier we mentioned that if using Jimmer's SpringBoot Starter, you can use the ready-made `org.babyfish.jimmer.spring.cache.RedisValueBinder` without having to adapt Redis yourself.

:::note
`RedisHashBinder` is related to [multi-view caches](./multiview-cache) and will not be discussed in this article.
:::

To build `RedisValueBinder`, you need a [RedisOperations<String, byte[]>](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisOperations.html).

Jimmer's SpringBoot Stater provides the `org.babyfish.jimmer.spring.cache.RedisCaches` class whose static method `RedisCaches.cacheRedisTemplate` can quickly build this [RedisOperations<String, byte[]>](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisOperations.html) object.

An example of the helper method `RedisCaches.cacheRedisTemplate` is as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java
@Bean
public CacheFactory cacheFactory(
    // highlight-next-line  
    RedisConnectionFactory connectionFactory,
    ObjectMapper objectMapper
) {

    RedisTemplate<String, byte[]> redisTemplate =
        // highlight-next-line
        RedisCaches.cacheRedisTemplate(connectionFactory);

    return new CacheFactory() {

        @Override
        @Nullable
        public Cache<?, ?> createObjectCache(@NotNull ImmutableType type) {
            return new ChainCacheBuilder<>()
                .add(
                    new CaffeineBinder<>(512, Duration.ofSeconds(1))
                )
                .add(
                    new RedisValueBinder<>(
                        // highlight-next-line
                        redisTemplate, 
                        objectMapper, 
                        type, 
                        Duration.ofMinutes(30)
                    )
                )
                .build();
        }

        @Override
        @Nullable
        public Cache<?, ?> createAssociatedIdCache(@NotNull ImmutableProp prop) {
            return createPropCache(prop, Duration.ofMinutes(10));
        }

        @Override
        @Nullable
        public Cache<?, List<?>> createAssociatedIdListCache(@NotNull ImmutableProp prop) {
            return createPropCache(prop, Duration.ofMinutes(5));
        }

        @Override
        @Nullable
        public Cache<?, ?> createResolverCache(@NotNull ImmutableProp prop) {
            return createPropCache(prop, Duration.ofMinutes(5));
        }

        private Cache<?, ?> createPropCache(ImmutableProp prop, Duration duration) {
            return new ChainCacheBuilder<>()
                .add(
                    new CaffeineBinder<>(512, Duration.ofSeconds(1))
                )
                .add(
                    new RedisValueBinder<>(
                        // highlight-next-line
                        redisTemplate, 
                        objectMapper, 
                        prop, 
                        duration
                    )
                )
                .build();
        }
    };
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean  
fun cacheFactory(
    // highlight-next-line
    connectionFactory: RedisConnectionFactory,
    objectMapper: ObjectMapper
): KCacheFactory {

    // highlight-next-line
    val redisTemplate = RedisCaches.cacheRedisTemplate(connectionFactory)

    return object: KCacheFactory {

        override fun createObjectCache(type: ImmutableType): Cache<*, *>? =
            ChainCacheBuilder<Any, Any>()
                .add(
                    CaffeineBinder(512, Duration.ofSeconds(1))
                )
                .add(
                    RedisValueBinder(
                        // highlight-next-line
                        redisTemplate, 
                        objectMapper, 
                        type, 
                        Duration.ofMinutes(30)
                    )
                )
                .build()

        override fun createAssociatedIdCache(prop: ImmutableProp): Cache<*, *>? =
            createPropCache(prop, Duration.ofMinutes(10))

        override fun createAssociatedIdListCache(prop: ImmutableProp): Cache<*, List<*>>? =
            createPropCache(prop, Duration.ofMinutes(5))

        override fun createResolverCache(prop: ImmutableProp): Cache<*, *>? =
            createPropCache(prop, Duration.ofMinutes(5))

        private fun createPropCache(type: ImmutableType, duration: Duration): Cache<*, *> =
            ChainCacheBuilder<Any, Any>()
                .add(
                    CaffeineBinder(512, Duration.ofSeconds(1))
                )
                .add(
                    RedisValueBinder(
                        // highlight-next-line
                        redisTemplate, 
                        objectMapper, 
                        prop, 
                        Duration.ofMinutes(10)
                    )
                )
                .build()
    }
}
```

</TabItem>
</Tabs>
