---
sidebar_position: 2
title: MapStruct
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Jimmer dynamic objects and static POJOs are completely different, they are a complete new technical system, which supports the entire Jimmer ORM.

However, sometimes we need to convert between Jimmer dynamics and ordinary static POJOs. For example, Jimmer itself recommends Input DTOs *(whether REST or GraphQL)* for API security.

:::caution 
For Kotlin, this approach is not recommended, [DTO Language](./dto-language) is more recommended. 

-   Problems with Kotlin

    -   This solution is based on [mapstruct framework](https://mapstruct.org/), and mapstruct framework is based on `apt`

    -   Kotlin has deprecated [kapt](https://kotlinlang.org/docs/kapt.html) and advocates the use of [ksp](https://kotlinlang.org/docs/ksp-overview.html)

    Therefore, as Kotlin evolves, using `kapt` may encounter more and more problems in the future.

-   The DTO types generated by the DTO language have built-in [Object Fetchers](../../query/object-fetcher), so
  
    -   They can be queried by underlying APIs, see [Object Fetcher/DTO Query](../../query/object-fetcher/dto)
    
    -   They can be queried by Spring Data style user code, see [Spring Data/Query DTO](../../spring/repository/dto)

    However, manually defined and MapStruct mapped DTOs do not have these features, they only support mutual conversion with dynamic entities.
:::

## Dependencies and Preprocessors

:::info
Jimmer chooses [MapStruct](https://github.com/mapstruct/mapstruct) as the technology for converting to and from static POJOs.
:::

For converting static POJOs to Jimmer dynamic objects, MapStruct does not know how to build Jimmer objects. So

- Jimmer's own preprocessor *(Java's `jimmer-apt` or Kotlin's `jimmer-ksp`)* generates some MapStruct-oriented code in Draft, allowing MapStruct to build Jimmer objects through its [Builder](https://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders) mode.

- Jimmer extends MapStruct's Annotation Processor. This extension allows MapStruct to utilize the capabilities reserved for MapStruct in the generated Draft to build Jimmer objects.

    This extension is called `jimmer-mapstruct-apt`

    - For Java, `jimmer-mapstruct-apt` is included in `jimmer-apt`

    - For Kotlin, `jimmer-ksp` and `jimmer-mapstruct-apt` must be used together in the maven or gradle configuration file

<Tabs groupId="buildTool">
<TabItem value="java_maven" label="Java(Maven)">

```xml title="pom.xml"
...omit other code...

<build>
    <dependencies>
        <dependency> ➀
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </dependency>
        <dependency> ➊
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        ...omit other dependencies...
    </dependencies>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.10.1</version>
            <configuration>
                <annotationProcessorPaths>
                    <path> ➁
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                        <version>${lombok.version}</version>
                    </path>
                    <path> ➋
                        <groupId>org.babyfish.jimmer</groupId>
                        <artifactId>jimmer-apt</artifactId>
                        <version>${jimmer.version}</version>
                    </path>
                    <path> ➌
                        <groupId>org.mapstruct</groupId>
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${mapstruct.version}</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>

...omit other code...
```

</TabItem>
<TabItem value="java_gradle" label="Java(Gradle)">

```groovy title="build.gradle"
dependencies {
    
    implementation "org.projectlombok:lombok:${lombok.version}" ➀
    implementation "org.mapstruct:mapstruct:${mapstructVersion}" ➊

    annotationProcessor "org.projectlombok:lombok:${lombok.version}" ➁
    annotationProcessor "org.babyfish.jimmer:jimmer-apt:${jimmerVersion}" ➋
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}" ➌

    ...omit other dependencies...
}
```

</TabItem>
<TabItem value="kotin_maven" label="Kotlin(Maven)">

```xml title="pom.xml" 
...omit other code...

<build>
    <sourceDirectory>src/main/kotlin</sourceDirectory>
    <testSourceDirectory>src/test/kotlin</testSourceDirectory>

    <dependencies>
        <dependency> ➊
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        ...omit other dependencies...
    </dependencies>

    <plugins>
        <plugin>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-maven-plugin</artifactId>
            <version>${kotlin.version}</version>
            <executions>
                <execution>
                    <id>compile</id>
                    <phase>compile</phase>
                    <goals>
                        <goal>compile</goal>
                    </goals>
                </execution>
                <execution>
                    <id>test-compile</id>
                    <phase>test-compile</phase>
                    <goals>
                        <goal>test-compile</goal>
                    </goals>
                </execution>
            </executions>
            <configuration>
                <compilerPlugins>
                    <compilerPlugin>ksp</compilerPlugin>
                </compilerPlugins>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.mapstruct</groupId> ➌
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${mapstruct.version}</version>
                    </path>
                    <path>
                        <groupId>org.babyfish.jimmer</groupId> a
                        <artifactId>jimmer-mapstruct-apt</artifactId>
                        <version>${jimmer.version}</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
            <dependencies>
                <dependency>
                    <groupId>com.dyescape</groupId>
                    <artifactId>kotlin-maven-symbol-processing</artifactId>
                    <version>1.3</version>
                </dependency>
                <dependency>
                    <groupId>org.babyfish.jimmer</groupId> ➋
                    <artifactId>jimmer-ksp</artifactId>
                    <version>${jimmer.version}</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>

...omit other code...
```

</TabItem>
<TabItem value="kotin_gralde" label="Kotlin(Gradle.kts)">

```kotlin title="build.gradle.kts"
plugins {
    id("com.google.devtools.ksp") version "1.7.10-1.0.6"
    kotlin("kapt") version "1.6.21"

    ...omit other plugins...
}
dependencies {
    
    implementation "org.mapstruct:mapstruct:${mapstructVersion}" ➊

    ksp("org.babyfish.jimmer:jimmer-ksp:${jimmerVersion}") ➋
    kapt("org.mapstruct:mapstruct-processor:${mapstructVersion}") ➌
	kapt("org.babyfish.jimmer:jimmer-mapstruct-apt:${jimmerVersion}") a

    ...omit other dependencies...
}

kotlin {
    sourceSets.main {
        kotlin.srcDir("build/generated/ksp/main/kotlin")
    }
}
```

</TabItem>
</Tabs>

In this example, we assume static POJOs are written in Java using [lombok](https://projectlombok.org/).

<table>
    <thead>
        <tr>
            <th>Language</th>
            <th>Location</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="3">Java and Kotlin</td>
            <td>➊</td>
            <td>Introduce mapstruct dependency for user code to use mapstruct annotations</td>
        </tr>
        <tr>
            <td>➋</td>
            <td>Use Jimmer's preprocessor to generate related source code for dynamic types, Java uses `jimmer-apt`, Kotlin uses `jimmer-ksp`</td>
        </tr>
        <tr>
            <td>➌</td>
            <td>Use mapstruct's annotation processor to generate source code <i>(introduced later)</i></td>
        </tr>
        <tr>
            <td rowspan="2">Java only</td>
            <td>➀</td>
            <td>Introduce lombok dependency for user code to use lombok annotations</td>
        </tr>
        <tr>
            <td>➁</td>
            <td>Use Lombok preprocessor to modify static POJO class code, e.g. add getters, setters</td>
        </tr>
        <tr>
            <td rowspan="2">Kotlin only</td>
            <td>a</td>
            <td>Use `jimmer-mapstruct-apt` to extend ➌</td>
        </tr>
    </tbody>
</table>

## Define POJO

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"
@Data
public class BookInput {

    @Nullable
    private Long id;

    private String name;

    private int edition;

    private BigDecimal price;

    @Nullable
    private Long storeId;

    private List<Long> authorIds;
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.java"
data class BookInput(
    val id: Long? = null,
    val name: String,
    val edition: Int,
    val price: BigDecimal,
    val storeId: Long?,
    val authorIds: List<Long>
)
```

</TabItem>
</Tabs>

:::note
The `@Nullable` annotation is used in the Java POJO code only to improve readability and has no functional effect
:::

Three properties of this POJO need to be explained:

-   `BookInput.id`

    - Here, `BookInput.id` is allowed to be null. This is necessary, for example, the id does not need to be specified when inserting data.

    - The dynamic attribute `Book.id` of the entity object does not allow null *(Jimmer prohibits id from being null, please refer to [Mapping/Basic Mapping/@Id](../../mapping/base/basic#id))*

    The two contradict each other, so how to convert `BookInput` to `Book`?

    :::tip
    Jimmer agrees that if the attribute of the POJO can be null while the corresponding attribute of the dynamic object cannot be null, the corresponding attribute of the dynamic object will not be assigned and will remain missing.
    :::

-   `BookInput.storeId`

    It is obvious that this is the associated id, corresponding to the dynamic attribute `Book.store` of the entity object.

    The dynamic object attribute is defined as an associated object, while the POJO is defined as an associated id, called short association mapping.

    :::info
    For the concept of short association, please refer to [here](../../mapping/advanced/view/id-view#基本概念短关联)
    :::

-   `BookInput.authors`

    It is obvious that this is a collection of associated ids, corresponding to the dynamic attribute `Book.store` of the entity object.

    The dynamic object attribute is defined as a collection of associated objects, while the POJO is defined as a collection of associated ids, called short association mapping.

    :::info
    For the concept of short association, please refer to [here](../../mapping/advanced/view/id-view#基本概念短关联)
    :::


The other properties are exactly the same as the original entity definition and need no explanation.

## Define Mapper

The most important thing when using mapstruct is to define the Mapper, as follows

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    Book toBook(BookInput input);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"  
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    fun toBook(input: BookInput): Book
}
```

</TabItem>
</Tabs>

This Mapper provides a `toBook` method to convert a `BookInput` object to a `Book` object. 

`BookInput.id`, `BookInput.id`, `BookInput.name` and `BookInput.price` are all non-associated properties that mapstruct can handle well.

:::note
The issue that `BookInput.id` can be null while `Book.id` cannot be null has been discussed before, so it won't be repeated here.
:::

The key is how `BookInput.storeId` and `BookInput.authorIds` should be mapped, which falls into two cases:

-   The entity defines @IdView properties  

-   The entity does not define @IdView properties

### If the entity defines @IdView properties

If the entity type defines `@IdView` properties, for example:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
package com.example.model;

import org.babyfish.jimmer.sql.*;
import org.jetbrains.annotations.Nullable;

@Entity
public interface Book {

    ...omit other properties...

    @ManyToOne
    @Nullable
    BookStore store();

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id"
    )
    List<Author> authors();

    // highlight-next-line
    @IdView // id view of associated object store  
    Long storeId();

    // id view of all objects in associated collection authors
    // highlight-next-line
    @IdView("authors")    
    List<Long> authorIds();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
package com.example.model

import org.babyfish.jimmer.sql.*

@Entity
interface Book {

    ...omit other properties...

    @ManyToOne
    val store: BookStore?

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id"
    )
    val authors: List<Auhtor>

    // highlight-next-line
    @IdView // id view of associated object store
    val storeId: Long?

    // id view of all objects in associated collection authors
    // highlight-next-line
    @IdView("authors") 
    val authorIds: List<Long>
}
```

</TabItem>
</Tabs>

In this case, the entity object and POJO correspond completely, and the Mapper does not need any modification.

### If the entity does not define @IdView properties

If the entity type does not define `@IdView` properties, the Mapper needs to be modified:

-   Convert `BookInput.storeId` to a `BookStore` object with only the id, then assign it to `Book.store`

-   Convert `BookInput.authorIds` to a collection of `Author` objects with only ids, then assign it to `Book.authors`

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store", source = "storeId") 
    // highlight-next-line
    @Mapping(target = "authors", source = "authorIds")
    Book toBook(BookInput input);

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    BookStore toBookStore(Long id);

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    Author toAuthor(Long id);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store", source = "storeId")
    // highlight-next-line 
    @Mapping(target = "authors", source = "authorIds")
    fun toBook(input: BookInput): Book

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    fun toBookStore(id: Long?): BookStore

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    fun toAuthor(id: Long?): Author
}
```

</TabItem>
</Tabs>

Since mapstruct also supports `@Mapping(target = "store.id", source = "storeId")`, the following syntax can also be used to simplify the code:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line  
    @Mapping(target = "store.id", source = "storeId")
    @Mapping(target = "authors", source = "authorIds")
    Book toBook(BookInput input);

    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = ".")
    Author toAuthor(Long id); 
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store.id", source = "storeId") 
    @Mapping(target = "authors", source = "authorIds")
    fun toBook(input: BookInput): Book

    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = ".")
    fun toAuthor(id: Long?): Author
}
```

</TabItem>
</Tabs>

## Usage

Now we can convert `BookInput` to `Book`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookInput input = ...omit...;
BookInputMapper mapper = Mappers.getMapper(BookInputMapper.class);
Book book = mapper.toBook(input);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val input: BookInput = ...omit...
val mapper = Mappers.getMapper(BookInputMapper::class.java)
val book = mapper.toBook(input)
```

</TabItem>
</Tabs>

## Make POJO implement Input interface

Jimmer provides a simple interface, `org.babyfish.jimmer.Input<E>`

```java
public interface Input<E> {

    E toEntity(); 
}
```

Dynamic objects will never implement this interface, this interface should be implemented by user-defined static POJO classes. Its function is very simple, just convert the current static POJO to a dynamic object.

This interface can provide convenience at the syntax level. Whether it is the underlying [save command](../../mutation/save-command) or the top-level spring-data base interface `JRepository/KRepository`, its `sava` method directly accepts `Input` parameters, without the user having to call the Mapper to complete the conversion.

If you want this convenience at the syntax level, you can choose to have the POJO implement this interface by modifying the `BookInput` code as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"  
@Data
public class BookInput implements Input<Book> { ❶

    private static final Converter CONVERTER =  
        Mappers.getMapper(Converter.class);

    ...omit private fields...

    @Override  
    public Book toEntity() { ❷
        return CONVERTER.toBook(this);
    }

    @Mapper
    interface Converter {

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        Book toBook(BookInput input);

        ...omit other mapstruct configuration... 
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.kt"
data class BookInput(
    ...omit... 
): Input<Book> { ❶

    override fun toEntity(): Book = ❷
        CONVERTER.toBook(this)

    @Mapper  
    internal interface Converter {  

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        fun toBook(input: BookInput): Book

        ...omit other mapstruct configuration...
    }

    companion object {

        @JvmStatic  
        private val CONVERTER =   
            Mappers.getMapper(Converter::class.java)  
    }
}
```

</TabItem> 
</Tabs>

-   ❶ `BookInput` class implements interface `org.babyfish.jimmer.Input`

-   ❷ Implement `Input.toEntity` method, use MapStruct to convert the current static `Input DTO` object to the dynamic `Book` entity object. This is the only function of this class.