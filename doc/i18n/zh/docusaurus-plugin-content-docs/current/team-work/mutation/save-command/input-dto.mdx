---
sidebar_position: 9
title: Input DTO
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ShortAssociation } from '@site/src/components/ShortAssociation';
import { LongAssociation } from '@site/src/components/LongAssociation';
import { ViewMore } from '@site/src/components/ViewMore';

## 安全性问题

截止到目前为止，我们已经系统性地讲解了保存指令的所有功能。

现在，我们知道了，无论要保存的数据结构的形状是什么，我们都可以使用一行代码调用保存指令将之写入数据库，所有的内部细节都被隐藏起来了，这一个非常便捷的底层功能。

然而，业务系统上层API该如何设计呢？直接用`@RequestBody`接受动态对象吗？

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@PutMapping("/book")
public void saveBook(
    // highlight-next-line
    @RequestBody Book book
) {
    bookRepository.save(book);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@PutMapping("/book")
fun saveBook(
    // highlight-next-line
    @RequestBody book: Book
) {
    bookRepository.save(book)
}
```

</TabItem>
</Tabs>

这段代码的确可以工作，允许HTTP客户端传入任意形状的的形状，这是看起来似乎是一个非常强大的功能。

然而，该方法存在两个问题：

-   较小的问题：对于insert操作而言，用户并不清楚必须指定哪些属性方可不报错。

-   较大的问题：客服端被赋予过于强大的能力，可以提交的很深很广的树形数据结构，远远超过当前安全策略允许它的修改的数据范围。这是巨大的安全漏洞。

    比如，客户端完全可以提交这样的数据

    ```json
    {
        "name": "SQL in Motion",
        "edtion": 1,
        "price": 41.99,
        "store":{
            "name": "MANNING",
            "location": {
                "city": "Vancouver",
                "contry": "Canada",
                ...略...
            }
        },
        "authors":[
            {
                "firstName": "Ben",
                "lastName": "Brumm",
                "job":{
                    "company": {
                        "name": "IBM"
                    },
                    "title": "Senior HR Manager",
                    ...略...
                }
                ...略...
            }
        ]
    }
    ```

    假如你提供这个HTTPAPI的本意是，能够被影响的表仅限于`BOOK`, `BOOK_STORE`, `AUTHOR`和`BOOK_AUTHOR_MAPPING`这四张表。

    然而，现在客户端提交的数据的波及范围太大，具备远超你所设想的破坏能力。上面的例子，至少存在4个意外破坏：

    -   `<root>.store.location.city`被修改，从`New York`变成`Vancouver`

    -   `<root>.store.location.contry`被修改，从`USA`变成`Canada`

    -   `<root>.authors[0].job.comany`被修改，从`NAB`变成`IBM`

    -   `<root>.authors[0].job.title`被修改，从`Senior Business Analyst`变成`Senior HR Manager`

:::warning
直接在对外API中使用`@RequestBody`接受动态对象作为Input参数，是一件非常危险的事，会导致严重的安全性问题。

因此，保持指令必须作为底层功能被封印在服务内部，绝对不能通过HTTP API直接暴露其原始能力。
:::

## 解决方案

### 定义Input DTO

既然用动态对象作为Input参数会导致严重的安全问题，那么我们就定义静态的POJO类作为输入参数，让给我们称其为`Input DTO`。

:::info
Jimmer宣称消灭DTO爆炸问题，指`Output DTO`，并非这里的的`Input DTO`，二者并不矛盾。
:::

让我们来看一个`InputDTO`的例子 *(为了简单，Java版本采用Lombok)*

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"
@Data
public class BookInput {

    @Nullable
    private Long id; ❶

    private String name;

    private int edition;

    private BigDecimal price;

    @Nullable
    private Long storeId; ❷

    private List<AuthorItem> authors; ❸

    @Data
    public static class AuthorItem {

        private String firstName;
        
        private String lastName;
        
        private Gender gender;
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.kt"
data class BookInput(
    val id: Long? = null, ❶
    val name: String, 
    val edition: Int,
    val price: BigDecimal, 
    val storeId: Long?, ❷
    val authors: List<AuthorItem> ❸
): Input<Book> {

    data class AuthorItem {
        val firstName: String,
        val lastName: String,
        val gender: Gender
    }
}
```

</TabItem>
</Tabs>

-   ❶ 由于保存指令的特性，id不是必须的。具体原理请回归[保存模式/总结](./save-mode#总结)

    :::info
    -   对于Jimmer实体而言，`id`不可能为null，靠id属性的缺失 *(即，不赋值)* 来表达对象没有id的情况。

    -   对于Input DTO而言，静态的POJO类型没有属性缺失的概念，靠null来表达没有id的情况。

    二者似乎是矛盾的，难以转化。别担心，Jimmer给出自动化的解决方案，后文论述。
    :::

-   ❷ 明确指定此InputDTO想以<ViewMore buttonText="短关联" variant="text"><ShortAssociation/></ViewMore>的方式编辑实体的多对一关联`Book.store`。其中，

-   ❸ 明确指定此InputDTO想以<ViewMore buttonText="长关联" variant="text"><LongAssociation/></ViewMore>的方式编辑实体的多对过关联`Book.authors`，
    关联对象的类型也被内嵌的InputDTO类型`BookInput.AuthorItem`固化。

### mapstruct转化器

Jimmer使用[mapstruct框架](https://mapstruct.org/)来处理动态实体和静态Input DTO之间的转化问题。

定义BookInputMapper接口，如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    Book toBook(BookInput input);

    ...省略其他mapstruct配置...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.kt"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    fun toBook(BookInput input): Book

    ...省略其他mapstruct配置...
}
```

</TabItem>
</Tabs>

:::info
需要使用mapstruct框架的预编译器在编译时生成此接口的实现类。这部分内容在[对象篇/和mapstruct协同](../../object/mapstruct)中有详细的说明，本文不再赘述。
:::

### HTTP API

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
private static final BookInputMapper BOOK_INPUT_MAPPER = 
    Mappers.getMapper(BookInputMapper.class);

@PutMapping("/book")
public void saveBook(
    // highlight-next-line
    @RequestBody BookInput input
) {
    bookRepository.save(
        // highlight-next-line
        BOOK_INPUT_MAPPER.toBook(input)
    );
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@PutMapping("/book")
fun saveBook(
    // highlight-next-line
    @RequestBody input: BookInput
) {
    bookRepository.save(
        // highlight-next-line
        BOOK_INPUT_MAPPER.toBook(input)
    )

    companion object {
        private val BOOK_INPUT_MAPPER =
            Mappers.getMapper(BookInputMapper::class.java)
    }
}
```

</TabItem>
</Tabs>

在这个例子中，利用mapstruct将`BookInput`转化为`Book`实体，直接保存即可。

:::info
-   对于Jimmer实体而言，`Book.id`不可能为null，靠其缺失 *(即，不赋值)* 来表达对象没有id的情况。

-   对于Input DTO而言，静态的POJO类型没有属性缺失的概念，靠`BookInput.id`为null来表达没有id的情况。

Jimmer内置了mapstruct的扩展，如果`BookInput.id`为null，则不会赋给`Book.id`，所以没有任何问题。
:::

可见，安全性保证问题，最终被转化成了使用mapstruct把Input DTO转化为Jimmer实体的问题。

### 改进

为了更好地和Jimmer配合，开发人员可以让`BookInput`实现`org.babyfish.jimmer.Input<E>`接口。

```java
public interface Input<E> {

    E toEntity();
}
```

动态对象永远不会实现这个此结构，该接口应该有用户自定义的静态POJO类来实现。其功能非常简单，就是把当前静态POJO转化为动态对象。

让`BookInput`实现`Input<Book>`，如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"
@Data
public class BookInput implements Input<Book> { 

    private static final Converter CONVERTER = 
        Mappers.getMapper(Converter.class);

    ...省略私有字段...

    @Override
    // highlight-next-line
    public Book toEntity() {
        return CONVERTER.toBook(this);
    }

    @Mapper
    interface Converter {

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        Book toBook(BookInput input);

        ...省略其他mapstruct配置...
    }

    ...省略内部类AuthorItem的定义...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.kt"
data class BookInput(
    ...略...
): Input<Book> {

    // highlight-next-line
    override fun toEntity(): Book = 
        CONVERTER.toBook(this)

    @Mapper
    internal interface Converter { 

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        fun toBook(input: BookInput): Book

        ...省略其他mapstruct配置...
    }

    companion object {

        @JvmStatic
        private val CONVERTER = 
            Mappers.getMapper(Converter::class.java)
    }

    ...省略内部类AuthorItem的定义...
}
```

</TabItem>
</Tabs>

:::info
在这个改进的例子中，之前介绍过的`BookInputMapper`被`BookInput.Converter`取代，因此可以删除之前介绍的`BookInputMapper`
:::

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@PutMapping("/book")
public void saveBook(
    // highlight-next-line
    @RequestBody BookInput input
) {
    // `save(input)`等价于`save(input.toEntity())`
    // highlight-next-line
    bookRepository.save(input);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@PutMapping("/book")
fun saveBook(
    // highlight-next-line
    @RequestBody input: BookInput
) {
    // `save(input)`等价于`save(input.toEntity())`
    // highlight-next-line
    bookRepository.save(input)
}
```

</TabItem>
</Tabs>

:::info
利用`Input<E>`接口改变开发风格是建议性的，不是强制的。
:::

## 最佳实践

在实际项目中，常常面临一个实际的问题，实体的属性可能非常多，而且

-   插入时需要指定的属性相对较多

-   修改时需要指定的属性相对较少

我们一致用作例子的`Book`等实体属性很少，不方便演示，因此，我虚构一个属性较多的实体类型：`Product`。

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Product.java"
@Entity
public interface Product { 

    ...省略实体属性...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Product.kt"
@Entity
interface Product { 

    ...省略实体属性...
}
```

</TabItem>
</Tabs>

-   针对插入时需要指定的属性相对较多的情况，定义`CreateProductInput`

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="CreateProductInput.java"
    @Data
    public class CreateProductInput implements Input<Product> { 

        ...较多字段，略...

        @Override
        public Product toEntity() {
            ...略...
        }
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="CreateProductInput.kt"
    data class CreateProductInput(
        ...较多字段，略...
    ) : Input<Product> { 

        @Override
        public Product toEntity() {
            ...略...
        }
    }
    ```

    </TabItem>
    </Tabs>

-   针对修改时需要指定的属性相对较少的情况，定义`UpdateProductInput`

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="UpdateProductInput.java"
    @Data
    public class UpdateProductInput implements Input<Product> { 

        ...较少字段，略...

        @Override
        public Product toEntity() {
            ...略...
        }
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="UpdateProductInput.kt"
    data class UpdateProductInput(
        ...较少字段，略...
    ) : Input<Product> { 

        @Override
        public Product toEntity() {
            ...略...
        }
    }
    ```

    </TabItem>
    </Tabs>

最后，提供两个HTTP API

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@PostMapping("/product")
public void createProduct(
    // `CreateProductInput`属性相对多
    // highlight-next-line
    @RequestBody CreateProductInput input
) {
    productRepository.insert(input);
}

@PutMapping("/product")
public void updateProduct(
    // `UpdateProductInput`属性相对少
    // highlight-next-line
    @RequestBody UpdateProductInput input
) {
    productRepository.update(input);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@PostMapping("/product")
fun createProduct(
    // `CreateProductInput`属性相对多
    // highlight-next-line
    @RequestBody input: CreateProductInput
) {
    productRepository.insert(input)
}

@PutMapping("/product")
fun updateProduct(
    // `UpdateProductInput`属性相对少
    // highlight-next-line
    @RequestBody input: UpdateProductInput
) {
    productRepository.update(input)
}
```

</TabItem>
</Tabs>

:::tip
由此可见，无论项目的业务特色决定需要为同一实体定义多少了不同的`Input DTO`类型。最终都是利用mapstruct将其转化为类型统一的动态实体对象，然后用一行代码调用保存指令即可。

哪怕项目的业务更复杂一些，比如不同身份的人可以编辑的数据结构的形状不同，也可以不断套用此模式轻松应对。
:::