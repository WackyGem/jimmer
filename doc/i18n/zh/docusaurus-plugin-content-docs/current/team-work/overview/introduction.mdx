---
sidebar_position: 1
title: 项目介绍
---

import { ViewMore } from '@site/src/components/ViewMore';
import { MindMap } from '@site/src/components/MindMap';
import { LongAssociation} from '@site/src/components/LongAssociation';
import DtoExplosion from '@site/static/img/dto-explosion.png'; 
import AssociationCache from '@site/static/img/association-cache.png';
import CalculatedCache from '@site/static/img/calculated-cache.png';
import MultiViewCache from '@site/static/img/multi-view-cache.png';

## Jimmer的是什么

Jimmer是一个针对Java和Kotlin的革命性ORM，以及一套基于它的完整的集成方案 *(包含一套强大的缓存管理机制)*。

### 1. Jimmer的定位

目前，有很多基于Java的关系型数据库上层技术方案，包括ORM风格和非ORM风格的。这类方案非常多，Jimmer不想再添重复。

事实上，对数据库完成CRUD访问只是实际项目中最基础最简单的一部分工作，还有其他一些工作一直控制着开发人员，它们更繁琐更复杂。比如

1.  DTO爆炸问题

    不同业务功能点对数据查询格式期望不同，往往导致项目需要定义大量的DTO类型，形成<ViewMore buttonText="DTO爆炸问题" variant="text"><img src={DtoExplosion}/></ViewMore>，而且开发人员还需要开发业务代码填充数据如此多的DTO类型，工作量非常巨大。

2.  复杂表单问题

    很多时候，客户端需要保存的数据结构并非扁平对象，而是<ViewMore buttonText="有一定复杂性的数据结构" variant="text"><LongAssociation/></ViewMore>，如果要开发人员自己对比客户端数据结构和现有数据的差异并执行适当的增、删、改行为，那会非常繁琐。
    
    而且，应该和查询功能类似，不同业务功能能对同一个聚合根类型保存的数据结构的格式应该多样化，不应在ORM层面通过配置固化。

3.  缓存

    -   是否使用缓存应该对开发人员绝对透明，缓存的引入不应该增加业务代码的复杂度、降低代码质量和可维护性，应该和纯SQL项目一样简单。

    -   缓存不应该仅有最简单的对象缓存，还应有用<ViewMore buttonText="关联缓存" variant="text"><img src={AssociationCache}/></ViewMore>和<ViewMore buttonText="计算缓存" variant="text"><img src={CalculatedCache}/></ViewMore>。

    -   以权限系统为代码表的全局过滤能力常常让不同用户看到不同的数据，因此，也应该<ViewMore buttonText="让不同用户看到不同缓存" variant="text"><img src={MultiViewCache}/></ViewMore>

    -   缓存的一致性维护应该被底层方案解决，尽可能做到全自动的，而非穿透到业务代码中由开发人员解决。

4.  客户端自动对接

    -   服务端服务应该自动为客户端 *(比如Web前端)* 生成客户端代码 *(比如TypeScript)*。

    -   服务端是生产者，开发人员希望看到简化后的API和编程模型，因为这意味着自己需要实现的工作少；客户端是消费者，开发人员希望看到完整的API和编程模型，因为这意味着自己用起来舒服。传统方案让服务端和客户端的API和编程模型完全一致不可取。

5.  微服务数据拼接

    在微型服务体系中，数据库是碎片化的。先从不同的微服务中查询数据的不同部分，然后拼接起来作为一个整体返回，这个操作既繁琐又高频，应该由底层方案隐藏和自动化。

:::tip
Jimmer收集业务项目开发中大部分既常见又繁琐的难题，给予一整套综合性解决方案。ORM只是Jimmer的切入点，而非全部。

Jimmer作为一个系统性大方案，绝非初学者眼中的又一个单纯的简单数据CRUD方案。但是经过慎重而富有创意和颠覆性的设计，Jimmer具备极高的`收益/成本`比。
:::

## 特色

### 1. 将关系型数据库抽象成图数据库

目前的关系型数据库上层技术以简单对象 *(以及对应的单表)* 操作为主，虽然传统ORM和MyBatis这类方案包含一些管理对象之间关联的能力，但相关能力非常有限。

Jimmer采用了与众不同的设计，将由多个相关联的对象组成的数据结构的边界形状控制能力提升到极致。

因此，无论读取还是写入，都以任意形状的数据结构以基本操作单元。即，关系型数据库在开发人员面前表现出了图形数据库的特征。

:::tip
理解并接受这个特征，将会在实际项目开发中获得巨大的便利性。
:::

:::note
此特征和GraphQL有点类似，但是存在明显差异

-   GraphQL只关注如何查询任意形状的数据结构，不关注如何写入任意形状的数据结构；Jimmer同时为查询和写入赋予这种能力。

-   GraphQL是一个基于HTTP的上层协议，跨越服务边界，由客户端发出远程调用是享受这种能力的唯一方法；这种能力在Jimmer中是更具有普适性的底层API，只要编写代码就能享受这种能力，即使服务内部也可以。
:::

### 2. 强大的缓存管理

自设计之初，Jimmer就认为缓存系统和关系型数据库同等重要，强大和缓存管理能力和数据库管理融为一体，相关难题也被一体化解决。而不是让缓存技术和ORM技术形成两个彼此割裂的两个领域，留给开发人员一堆难题

-   Jimmer的缓存系统对开发人员完全透明，对业务代码零侵入。

    如果只阅读业务代码，用户甚至不知道幕后是单纯的数据操作还是融合了缓存管理。

-   大部分情况下，开发人员以前在项目中实现的缓存很简单，功能很单一，就是从id到对象的映射。*(本质原因是因为这种缓存同步起来很简单)*

    Jimmer不仅支持这种最基础的缓存数据，还支持更高级的缓存数据。比如，数据之间的关联关系，也会被缓存。
    
    多种缓存数据在幕后彼此配合，最终为用户呈现任意形状的数据结构的缓存，而非仅仅是简单对象的缓存。

-   在以前的项目中，保证缓存和数据库的一致性，是一个非常头疼的问题。

    对于绝大部分缓存，Jimmer都提供了全自动的一致性维护能力。如果阅读修改数据的业务代码，用户看不到任何和缓存一致性维护相关的逻辑。

:::tip
总之，在Jimmer中，你可以享受缓存系统的所有优点，但是，你付出的代价可以忽略不计。业务代码的复杂度和纯数据库项目相差无几。
:::

### 3. 一体化集成解决方案

一般而言，狭义的ORM只是项目开发中很小一部分。然而，Jimmer源于ORM却不限于ORM，它不仅是一个强大的ORM，还是以ORM为基础的一套面向后端的一体化集成解决方案。

所以，Jimmer解决的问题不限于传统狭义ORM的范围，它对很多其他功能进行了整合。

:::tip
由于这种一体化集成解决方案的特性，你会发现，使用Jimmer后，项目需要使用的其他框架的数量会明显减少。
:::

## Jimmer提供了那些功能

<MindMap initialExpandLevel={1}/>

本文档后后学章将会逐步讨论这些功能。

## 高光功能

-   [对象抓取器](../query/object-fetcher)
-   [Save指令](../mutation/save-command)
-   [动态表连接](../query/dynamic-join)
-   [缓存及一致性](../cache)
-   [智能分页](../query/paging)

