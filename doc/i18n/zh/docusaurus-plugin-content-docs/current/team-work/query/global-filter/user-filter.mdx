---
sidebar_position: 2
title: 自定义过滤器
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## 提供抽象实体基类

首先，提供一个`MappedSuperclass`超类型，让所有需要多租户管理的实体类都继承它

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@MappedSuperclass
public interface TenantAware {

    String tenant();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@MappedSuperclass
interface TenantAware {

    val tenant: String
}
```

</TabItem>
</Tabs>

:::tip
诚然，可以不定义抽象类型，直接对实体类型施加过滤器，这没有任何问题。

然而，更推荐的方法是从实体中提取抽象类型，这样一个过滤器可以过滤多种实体类型。

更重要的是，`MappedSupperClass`支持多继承，即实体类型可以从多个超类型继承。多继承和全局过滤器相结合后可以带来惊人的灵活性。
:::

## 定义过滤器

假设Spring上下文中有一个类型为`TenantProvider`的对象，其Java方法`get()`和kotlin属性`tenant`用于从当前操作者身份信息中提取所属租户。定义如下过滤器

- Java下，拦截器需实现`org.babyfish.jimmer.sql.filter.Filter`接口，
- Kotlin下，拦截器需实现`org.babyfish.jimmer.sql.kt.filter.KFilter`接口。

如果使用Spring托管，代码方式如下：

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Component
public class TenantFilter implements Filter<TenantAwareProps> {

    private final TenantProvider tenantProvider;

    public TenantFilter(TenantProvider tenantProvider) {
        this.tenantProvider = tenantProvider;
    }

    @Override
    public void filter(FilterArgs<TenantAwareProps> args) {
        String tenant = tenantProvider.get();
        if (tenant != null) {
            args.where(args.getTable().tenant().eq(tenant));
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Component
class TenantFilter(
    private val tenantProvider: TenantProvider
) : KFilter<TenantAware> {

    override fun filter(args: KFilterArgs<TenantAware>) {
        tenantProvider.tenant?.let {
            args.apply {
                where(table.tenant.eq(it))
            }
        }
    }
}
```

</TabItem>
</Tabs>

Java和Kotlin的过滤器定义略有不同

-   Java中，`Filter`的范型参数为`TenantAwareProps`，这是与编译器针对抽象类型`TenantAware`自动生成的代码之一

-   Kotlin中，`KFilter`的范型参数是抽象类型`TenantAware`本身

`TenantFilter`过滤抽象类型`TenantAware`，对于任何直接或间接继承抽象接口`TenantAware`的实体而言，其查询都会被这个过滤器处理，自动添加where条件。

`TenantFilter`内部，首先从提取当前操作者身份信息中提取其所属租户，如果所属租户非null，则使用它来过滤数据，只查询和指定租户匹配的数据。

### Spring环境下配置过滤器

上文中，我们定义的类`TenantFilter`被`@Compoent`修饰，很明显这是一个Spring托管对象。

:::info
如果使用Jimmer的SpringBoot Starter且保证过滤器被Spring托管，那么Jimmer就会将注册它，无需额外的配置。

否则，必需手动注册
:::

### 非Spring环境下配置过滤器

将过滤器挂接到SqlClient对象上，即可生效

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
JSqlClient sqlCLient = JSqlBuilder
    .newBuilder()
    // highlight-next-line
    .addFilter(new CustmerFilter())
    ...省略其他配置...
    .build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val sqlClient =
    newKSqlClient {
        // highlight-next-line
        addFilters(new CustmerFilter())
        ...省略其他配置...
    }
```

</TabItem>
</Tabs>

## 过滤聚合根对象

过滤聚合根对象是全局过滤器最简单的用法。

假设`Book`实体继承了`TenantAware`，用法如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient.getEntities.findAll(Book.class);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient.entities.findAll(Book::class);
```

</TabItem>
</Tabs>
或
<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable book = BookTable.$;
List<Book> books = sqlClient
    .createQuery(book)
    .select(book)
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = SqlClient
    .createQuery(Book::class) {
        select(table)
    }
    .execute()
```

</TabItem>
</Tabs>

生成的SQL如下

```sql
select 
    tb_1_.ID, 
    tb_1_.TENANT, 
    tb_1_.NAME, 
    tb_1_.EDITION, 
    tb_1_.PRICE, 
    tb_1_.STORE_ID 
from BOOK as tb_1_
/* highlight-next-line */ 
where tb_1_.TENANT = ?
```

不难发现，这里使用了最简单的查询，没有任何查询参数。但是最终生产的SQL仍然过滤了`tb_1_.TENANT`

## 过滤关联对象

不仅可以过滤聚合根对象，关联对象也可以被过滤。用法如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Author> authors = sqlClient.getEntities.findAll(
    AuthorFetcher.$
        .allScalarFields()
        // highlight-next-line
        .books(
            BookFetcher.$
                .allScalarFields()
        )
);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient.entities.findAll(
    newFetcher(Author::class).by {
        allScalarFields()
        // highlight-next-line
        books {
            allScalarFields()
        }
    }
);
```

</TabItem>
</Tabs>
或
<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
AuthorTable author = AuthorTable.$;
List<Author> authors = sqlClient
    .createQuery(author)
    .select(
        author.fetch(
            AuthorFetcher.$
                .allScalarFields()
                // highlight-next-line
                .books(
                    BookFetcher.$
                        .allScalarFields()
                )
        )
    )
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val authors = SqlClient
    .createQuery(Author::class) {
        select(
            table.fetchBy {
                allScalarFields()
                // highlight-next-line
                books {
                    allScalarFields()
                }
            }
        )
    }
    .execute()
```

</TabItem>
</Tabs>

这会导致如下两句SQL被生成

1.  查询聚合根
    ```sql
    select 
        tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME, tb_1_.GENDER 
    from AUTHOR as tb_1_
    ```

2.  查询关联对象
    ```sql
    select 
        tb_2_.AUTHOR_ID, 
        tb_1_.ID, 
        tb_1_.TENANT, 
        tb_1_.NAME, 
        tb_1_.EDITION, 
        tb_1_.PRICE 
    from BOOK as tb_1_ 
    inner join BOOK_AUTHOR_MAPPING as tb_2_ 
        on tb_1_.ID = tb_2_.BOOK_ID 
    where 
        tb_2_.AUTHOR_ID in (?, ?, ?, ?, ?) 
    and 
        /* highlight-next-line */
        tb_1_.TENANT = ?
    ```

## 禁用过滤器

调用`sqlClient.filters`，在不影响当前`sqlClien`的前提下，创建新的临时SqlClient，可以达到禁用过滤器的目的。

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
JSqlClient tmpSqlClient =
    sqlClient.filters(it -> {
        it
            // highlight-next-line
            .disableByTypes(TenantFilter.class);
    });
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val tmpSqlClient = 
    sqlClient.filters {
        // highlight-next-line
        disableByTypes(TenantFilter::class)
    }
```

</TabItem>
</Tabs>

这里，我们得到了一个临时的的`tmpSqlClient`，基于它创建的查询将会无视上面演示的过滤器。

## Sharding过滤器

Jimmer提供按照id *(或id集合)* 查询实体 *(或实体集合)* 的简单API。

默认情况下，这类API是特殊的，它们无视全局过滤器。因为，因为id唯一确定了对象，按照id查询对象忽略过滤器是正确的。

然而，如果JDBC层面使用了[sharding-jdbc](https://shardingsphere.apache.org/document/4.1.1/en/manual/sharding-jdbc/)技术，且在过滤器中被用作筛选条件的字段就是sharding-jdbc中分库分表的字段，这时，仅仅根据id查询会导致sharding-jdbc查询多个分片，这是灾难。

为了解决这个问题，让过滤器实现`ShardingFilter`接口*(Java)*或`KShardingFilter`接口*(Kotlin)*即可，该接口无任何行为，仅仅做类型标记。

一旦过滤器继承了`ShardingFilter`或`KShardingFilter`，这类简单API将不再忽略过滤此过滤器。这可以保证最终SQL一定包含sharding-jdbc所需的sharding字段，从而实现只查询单个分片，而非所有分片都查询一次。
